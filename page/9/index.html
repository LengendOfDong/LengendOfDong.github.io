<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lengendofdong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lengendofdong.github.io/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lengendofdong.github.io/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="history fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="list fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-tools"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/" rel="section"><i class="briefcase fa-fw"></i>tools</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/1.webp">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：Java8用流收集数据"><a href="#原创：Java8用流收集数据" class="headerlink" title="原创：Java8用流收集数据"></a>原创：Java8用流收集数据</h1><h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><h3 id="统计总数"><a href="#统计总数" class="headerlink" title="统计总数"></a>统计总数</h3><p>利用收集器来统计菜单中有多少中菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long howManyDishes = menu.stream().collect(Collectors.counting());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h3><p>可以使用两个收集器，Collectors.maxBy和Collectors.minBy,来计算流中的最大值和最小值。这两个收集器接收一个Comparator参数来比较流中的元素。可以创建一个Comparator来根据所含热量对菜肴进行比较，并把它传递给Collectors.maxBy:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&amp;lt;Dish&amp;gt; dishCaloriesComparator = </span><br><span class="line">	Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&amp;lt;Dish&amp;gt; mostCaloriesDish = </span><br><span class="line">	menu.stream().collect(maxBy(dishCaloriesComparator))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接收一个把对象映射为求和所需Int的函数，并返回一个收集器;该收集器在传递给普通的collect方法后即执行我们所需要的汇总操作。举个例子，可以这样求出菜单列表的总热量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，汇总不仅仅是求和：还有Collectors.averagingInt，连同对应的averagingLong和averagingDouble可以计算数值的平均数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double avgCalories = </span><br><span class="line">	menu.stream().collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过一次summerizing操作就可以数出菜单中元素的个数，并得到菜肴热量总和、平均值、最大值和最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics = </span><br><span class="line">	menu.stream().collect(summarizingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印menuStaticsticObject会得到：<br/><br>IntSummaryStatistics{count&#x3D;9,sum&#x3D;4300,min&#x3D;120,average&#x3D;477.77778,max&#x3D;800}</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。可以使用这种方法，把菜单中的菜肴名称都连接起来，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName()).collect(joining());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>joining在内部使用了StringBuilder来把生成的字符串逐个追加起来。<br/><br>如果Dish类本身就有一个toString方法来返回菜肴的名称，可以使用下面方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过使用joining工厂方法的一个重载版本，可以得到一个逗号分隔的菜肴名称列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining(&quot;,&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>假如要把菜单中的菜按照类型进行分类，有肉的放一组，有鱼的放一组，其他的都放另一组。用Collectors.groupingBy工厂方法返回的收集器就可以轻松完成这项任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Dish.Type,List&amp;lt;Dish&amp;gt;&amp;gt; dishesByType = </span><br><span class="line">	menu.stream().collect(groupingBy(Dish::getType));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为下面的Map:<br/><br>{FISH&#x3D;[prawns,salmon],OTHER&#x3D;[french fries,rice,season fruit,pizza],MEAT&#x3D;[pork,beef,chicken]}</p>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><p>要实现多级分组，可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum CaloricLevel(DIET,NORMAL,FAT&#125;</span><br><span class="line">Map&amp;lt;Dish.Type,Map&amp;lt;CaloricLevel,List&amp;lt;Dish&amp;gt;&amp;gt;&amp;gt; dishesByTypeCaloricLevel =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    	groupingBy(Dish::getType,</span><br><span class="line">    		groupingBy(dish -&amp;gt; &#123;</span><br><span class="line">    			if (dish.getCalories() &amp;lt;= 400) return CaloricLevel.DIET;</span><br><span class="line">    			else if(dish.getCalories() &amp;lt;=700) return CaloricLevel.NORMAL;</span><br><span class="line">    			else return CaloricLevel.FAT;</span><br><span class="line">    			&#125;)</span><br><span class="line">    		)</span><br><span class="line">    	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外groupingBy和其他收集器联合使用也可以，例如groupingBy和mapping收集器结合起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Dish.Type,Set&amp;lt;CaloricLevel&amp;gt;&amp;gt; caloricLevelByType = </span><br><span class="line">	menu.stream().collect(</span><br><span class="line">		groupingBy(Dish::getType,mapping(</span><br><span class="line">			dish-&amp;gt; &#123; if (dish.getCalories() &amp;lt;= 400 ) return CaloricLevel.DIET;</span><br><span class="line">			else if (dish.getCalories() &amp;lt;= 700 ) return CaloricLevel.NORMAL;</span><br><span class="line">			else return CaloricLevel.FAT;</span><br><span class="line">			&#125;,toSet()</span><br><span class="line">			)</span><br><span class="line">		) </span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，称为分区函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Boolean,List&amp;lt;Dish&amp;gt;&amp;gt; partitionedMenu =</span><br><span class="line">	menu.stream().collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到partitioningBy(Dish::isVegetarian)和groupingBy(Dish::getType)很相似，就是返回的类型不一样罢了。<br/><br>找出所有的素食菜肴，利用get方法获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianDishes = partitionedMenu.get(true);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用下面的方法也可以获得同样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianDishes = menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E6%95%B0%E5%80%BC%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E6%95%B0%E5%80%BC%E6%B5%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：Java8数值流"><a href="#原创：Java8数值流" class="headerlink" title="原创：Java8数值流"></a>原创：Java8数值流</h1><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>背景：<br/><br>当计算菜单的热量时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int calories = menu.stream().map(Dish::getCalories).reduce(0,Integer::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：<br/><br>上例中暗含了装箱的成本，每个Integer都必须拆箱成一个原始类型，再进行求和。</p>
<p>解决方法：<br/><br>Java8中引入了三个原始类型特化流接口来解决这个问题：IntStream,DoubleStream和LongStream，分别将流中的元素特化为int,long和double，从而避免了暗含的装箱成本。<br/><br>1.映射到数值流<br/><br>将流转换为特化版本的常用方法时mapToInt，mapToDouble和mapToLong。这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream。例如，可以用mapToInt对menu中的卡路里求和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int calories  = menu.stream().mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.转换回对象流<br/><br>同样，一旦有了数值流，你可能会想把它转换回非特化流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&amp;lt;Integer&amp;gt; stream = intStream.boxed();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.默认值OptionalInt<br/><br>Optional可以用Integer，String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt,OptionalDouble和OptionalLong。</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>Java8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。例如选出1到100中的偶数个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.rangeClosed(1,100).filter(n -&amp;gt; n % 2 == 0);</span><br><span class="line">System.out.println(evenNumbers.count());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例的结果返回的是50，rangeClosed是算上结束值的。<br/><br>如果改用IntStream.range(1,100),则结果将会是49个偶数，因为range是不包含结束值的。</p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>可以使用静态方法Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。例如，下面的代码直接使用Stream.of创建一个字符串流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;Java 8&quot;,&quot;Lambda&quot;,&quot;In &quot;,&quot;Action&quot;);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，还可以使用empty得到一个空流，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&amp;lt;String&amp;gt; emptyStream = Stream.empty();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><p>可以使用静态方法Arrays.stream从数组创建一个流，接受一个数组作为参数。例如，可以将一个原始类型int的数组转换成一个IntStream,如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;2,3,5,7,11,13&#125;;</span><br><span class="line">int sum = Arrays.stream(numbers).sum();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="从文件生成流"><a href="#从文件生成流" class="headerlink" title="从文件生成流"></a>从文件生成流</h3><p>Java中用于处理文件等I&#x2F;O操作的NIO api已更新，以便利用Stream api。java.nio.file.Files中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines,它会返回一个由指定文件中的各行构成的字符串流。例如下面的例子中查看一个文件中有多少个不相同的词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long uniqueWords = 0;</span><br><span class="line">try(Stream&amp;lt;String&amp;gt; lines = </span><br><span class="line">		Files.lines(Paths.get(&quot;data.txt&quot;),Charset.defaultCharset()))&#123;</span><br><span class="line">	uniqueWords = lines.flatMap( line -&amp;gt; Arrays.stream(line.split(&quot; &quot;)))</span><br><span class="line">			.distinct().count()</span><br><span class="line">	)</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate.这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。一般来说，应该使用limit(n)来对这种流加以限制，以避免打印无穷多个值。<br/><br>1.迭代</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(0,n -&amp;gt; n + 2）.limit(10).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中每次生成的值都作为下次循环的参数，初始值为0，每次迭代增加2，2，4，6，8…<br/><br>2.生成<br/><br>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数 的。它接受一个Supplier类型的Lambda提供新的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">		.limit(5).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E4%BD%BF%E7%94%A8%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-Java8%E4%BD%BF%E7%94%A8%E6%B5%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：Java8使用流"><a href="#原创：Java8使用流" class="headerlink" title="原创：Java8使用流"></a>原创：Java8使用流</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><h3 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h3><p>Stream接口支持filter方法。该操作会接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。例如筛选出菜单中所有的素菜，创建一张素食菜单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><p>  流还支持一个叫做distinct的方法，它会返回一个元素各异的流。例如，筛选出列表中所有的偶数，并确保没有重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1,2,1,3,3,2,4);</span><br><span class="line">numbers.stream().filter(i -&amp;gt; i % 2 == 0 ).distinct().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="截短流"><a href="#截短流" class="headerlink" title="截短流"></a>截短流</h3><p>  流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。比如，建立一个List，选出热量超过300卡路里的头三道菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; dishes = menu.stream().filter(d -&amp;gt; d.getCalories() &amp;gt; 300).limit(3).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：limit也可以用在无序流上，比如源是一个Set。在这种情况下，limit的结果不会以任何顺序排列。</p>
<h3 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h3><p>  流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。<br/><br><strong>注意</strong>:limit(n)和skip(n)是互补的，例如，下面的代码将跳过超过300卡路里的头两道菜，并返回剩下的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; dishes = menu.stream().filter(d -&amp;gt; d.getCalories() &amp;gt; 300 ).skip(2).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>  一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具。</p>
<h3 id="对流中每一个元素应用函数"><a href="#对流中每一个元素应用函数" class="headerlink" title="对流中每一个元素应用函数"></a>对流中每一个元素应用函数</h3><p>  流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是”创建一个新版本“而不是去”修改“)。例如，下面的代码把方法引用Dish::getName传给了map方法，来提取流中菜肴的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;String&amp;gt; dishNames =  menu.stream().map(Dish::getName).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要找出每道菜的名称有多长，怎么做？可以如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; dishNameLengths = menu.stream().map(Dish::getName).map(String::length).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一步是获取流中的菜肴名称，然后再获取菜肴名称的长度，返回一个List</p>
<h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>  对于一张单词表，如何返回一张列表，列出里面各不相同的字符呢？例如，给定单词列表[“Hello”,“World”],你想要返回列表[“H”,“e”,“l”,“o”,“W”,“r”,“d”]。<br/><br>可以使用flatMap来达到目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;String&amp;gt; uniqueCharacters = words.stream().map(w -&amp;gt; w.split(&quot;&quot;)).flatMap(Arrays::stream).distinct().collect(Collections.toList())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容（数组中的内容映射出来，形成一个流的内容，实现了流的合并）。所有使用map(Arrays::stream)时生成的单个流都被合并起来，扁平化为一个流。<br/><br>总之，flatMap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p>
<h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><p>  另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch,anyMatch,noneMatch,findFirst和findAny方法提供了这样的工具。</p>
<h3 id="检查谓词是否至少匹配一个元素"><a href="#检查谓词是否至少匹配一个元素" class="headerlink" title="检查谓词是否至少匹配一个元素"></a>检查谓词是否至少匹配一个元素</h3><p>anyMatch方法可以回答”流中是否有一个元素能匹配给定的谓词“。比如，你可以用它来看看菜单里面是否有素食可选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if （menu.stream().anyMatch(Dish::isVegetarian)）&#123;</span><br><span class="line">	System.out.println(&quot;The menu is vegetarian friendly!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查谓词是否匹配所有元素"><a href="#检查谓词是否匹配所有元素" class="headerlink" title="检查谓词是否匹配所有元素"></a>检查谓词是否匹配所有元素</h3><p>使用allMatch检查菜品的热量是否都小于1000卡路里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean isHealthy = menu.stream().allMatch(d -&amp;gt; d.getCalories() &amp;lt; 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与此相对的是noneMatch，可以重写上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean isHealthy = menu.stream().noneMatch(d -&amp;gt; d.getCalories() &amp;gt;= 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用。可以结合使用filter和findAny方法来实现查询素食菜肴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Dish&amp;gt; dish = menu.stream().filter(Dish::isVegetarian).findAny();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h3><p>  有些流有一个出现顺序来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。给定一个数字列表，下面的代码能找出第一个平方能被3整除的数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; someNumbers = Arrays.aslist(1,2,3,4,5);</span><br><span class="line">Optional&amp;lt;Integer&amp;gt; firstSquareDivisibleByThree = </span><br><span class="line">		someNumbers.stream().map(x -&amp;gt; x * x).filter(x -&amp;gt; x % 3 == 0)</span><br><span class="line">					.findFirst();//9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：何时使用findFirst和findAny<br/><br>找到第一个元素在并行上限制更多，如果不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制更少。</p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><h3 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h3><p>对元素求和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,(a,b) -&amp;gt; a + b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变形后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,(a,b) -&amp;gt; Integer.sum(a,b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再进一步变形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,Integer::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于无初始值的情况：<br/><br>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; sum = numbers.stream().reduce((a,b) -&amp;gt; a + b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当流中没有任何元素是，reduce操作无法返回其和，因为它没有初始值。这就是为什么包裹在一个Optional对象里，以表明和可能不存在。</p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>计算最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; min = numbers.stream().reduce(Integer::min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算流中个数：<br/><br>方法一：int count &#x3D; menu.stream().map(d -&gt; 1).reduce(0,(a,b) -&gt; a + b);<br/><br>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。<br/><br>方法二：long count &#x3D; menu.stream().count();</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：HTTP首部（一）"><a href="#原创：HTTP首部（一）" class="headerlink" title="原创：HTTP首部（一）"></a>原创：HTTP首部（一）</h1><h1 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h1><p>HTTP报文的结构如下所示:</p>
<p>|报文首部<br>|——<br>|空行（CR+LF）<br>|报文主体</p>
<p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。<br/><br>在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成<br/><br>在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成。</p>
<h1 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h1><h2 id="HTTP首部字段传递重要信息"><a href="#HTTP首部字段传递重要信息" class="headerlink" title="HTTP首部字段传递重要信息"></a>HTTP首部字段传递重要信息</h2><p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号”:”分隔</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首部字段名：字段值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如，在HTTP首部中以Content-Type这个字段来表示报文主体的对象类型<br/><br>Content-Type:text&#x2F;html<br/><br>字段值对应单个HTTP首部字段可以有多个值，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keep-Alive:timeout=15,max=100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h2><p>HTTP首部字段根据实际用途被分为以下4种类型。</p>
<h2 id="End-to-end-首部和Hop-by-hop首部"><a href="#End-to-end-首部和Hop-by-hop首部" class="headerlink" title="End-to-end 首部和Hop-by-hop首部"></a>End-to-end 首部和Hop-by-hop首部</h2><p>HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型。</p>
<h1 id="HTTP-x2F-1-1通用首部字段"><a href="#HTTP-x2F-1-1通用首部字段" class="headerlink" title="HTTP&#x2F;1.1通用首部字段"></a>HTTP&#x2F;1.1通用首部字段</h1><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。<br/><br>Cache-Control指令：</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Connection首部字段具备如下两个作用：</p>
<p>控制代理不再转发的首部字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:不再转发的首部字段名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>管理持久连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:close</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTTP&#x2F;1.1版本默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTTP&#x2F;1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive.</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>首部字段Date表明创建HTTP报文的日期和时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date :Tue, 03 Jul  2012  04:40:59 GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>该指令作为与HTTP&#x2F;1.0的向后兼容而定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pragma:no-cache</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源</p>
<h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><p>首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP&#x2F;1.1版本分块传输编码时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Trailer: Expires</span><br><span class="line">...(报文主体)...</span><br><span class="line">0</span><br><span class="line">Expires:Tue,28 Sep  2004  23:59:59  GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面例子中，指定首部字段Trailer的值为Expires,在报文主体之后（分块长度0之后）出现了首部字段Expires</p>
<h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer -Encoding"></a>Transfer -Encoding</h2><p>首部字段Transfer-Encoding规定了传输报文主体是采用的编码方式。</p>
<h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><p>首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
<h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><p>使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。<br/><br>报文经过代理或者网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。<br/><br>首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。<br/><br>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET   /   HTTP/1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过代理服务器之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  /   HTTP/1.1</span><br><span class="line">Via: 1.0  gw.hackr.jp(Squid/3.1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>HTTP&#x2F;1.1的Warning首部是从HTTP&#x2F;1.0的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题警告<br/><br>该首部的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning:[警告码][警告的主机：端口号]&quot;[警告内容]&quot;([日期时间])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTTP&#x2F;1.1定义了7种警告，警告码如下：</p>
<p>|警告码|警告内容|说明<br>|——<br>|110|Response is stale(响应已过期)|代理返回已过期的资源<br>|111|Revalidation  failed(再验证失败)|代理再验证资源有效性时失败（服务器无法到达等原因）<br>|112|Disconnection operation(断开连接操作)|代理与互联网连接被故意切断<br>|113|Heuristic expiration(试探性过期)|响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）<br>|199|Miscellaneous warning(杂项警告)|任意的警告内容<br>|214|Transformation applied(使用了转换)|代理对内容编码或媒体类型等执行了某些处理时<br>|299|Miscellaneous persistent warning(持久杂项警告)|任意的警告内容</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：HTTP首部（三）"><a href="#原创：HTTP首部（三）" class="headerlink" title="原创：HTTP首部（三）"></a>原创：HTTP首部（三）</h1><h1 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h1><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段。用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<h2 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges:bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。<br/><br>可指定的字段值有两种，可处理范围请求时指定其为bytes,反之则指定其为none。</p>
<h2 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Age:600</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。<br/><br>若创建该响应的服务器为缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。</p>
<h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag:&quot;9819364440793772187&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。<br/><br>资源被缓存时，就会被分配唯一性标识。<br/><br>强ETag值和弱ETag值<br/><br>ETag中有强ETag值和弱ETag值之分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag:&quot;usagi-1234&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;usagi-1234&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /sample.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回重定向，位置转移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">302  Found</span><br><span class="line">Location:http://www.usagedesign.jp/sample.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据返回的location,重新发起请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  /sample.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回响应成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源。<br/><br>基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI.</p>
<h2 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate:Basic  realm=&quot;Usagidesign Auth&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端<br/><br>该认证行为是在客户端与代理之间进行的。</p>
<h2 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Retry-After:120</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例表示120秒后再尝试访问<br/><br>首部字段Retry-After告知客户端应该在多久之后再次发送请求。主要配合状态码503 Service Unavailable响应，或3xx Redirect响应一起使用。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server:Apache/2.2.17(Unix)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>
<h2 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vary:Accept-Language</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Vary即改变的意思，如何理解改变？<br/><br>指的是响应的返回方式进行了改变<br/><br>当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回。</p>
<h2 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge）。</p>
<h1 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h1><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>
<h2 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Allow:GET,HEAD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405  Method Not Allowed作为响应返回。与此同时，还会把能支持的HTTP方法写入首部字段Allow后返回。</p>
<h2 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding:gzip</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Content-Encoding会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<h2 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Language:zh-Cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Content-Language会告知客户端，实体主体使用的自然语言（指中文或英文等语言）</p>
<h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Length:15000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Content-Length表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用Content-Length首部字段。</p>
<h2 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Location:http://www.hackr.jp/index-ja.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Content-Location给出与报文主体部分相对应的URI。和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI。</p>
<h2 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-MD5:OGFKZUwHDGSGEWEewewrweiH==</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Content-MD5的目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。<br/><br>客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值进行比较,即可判断出报文主体的准确性。<br/><br>注：采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改，因为Content-MD5也可重新计算然后被篡改。</p>
<h2 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Range:bytes 5001-10000/10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对范围请求，返回响应时使用的首部字段Content-Range,能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type:text/html;charset=UTF-8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Content-Type说明了实体主体内对象的媒体类型。和首部字段Accept一样，字段值用type&#x2F;subtype形式赋值。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expires：Wed, 04  Jul  2012  08:26:05  GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Expires会将资源失效的日期告知客户端。<br/><br>缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified:Mon, 23 Oct 2017 10:01:51 GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Last-Modified指明资源最终修改的时间。一般来说，这个值就是Request-URI指定资源被修改的时间。</p>
<h1 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h1><p>为Cookie服务的首部字段如下：</p>
<p>|首部字段名|说明|首部类型<br>|——<br>|Set-Cookie|开始状态管理所使用的Cookie信息|响应首部字段<br>|Cookie|服务器接收到的Cookie信息|请求首部字段</p>
<h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: BD_CK_SAM=deleted; expires=Thu, 01-Jan-1970 17:00:00 GMT; path=/; domain=.m.baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。<br/><br>下面的表格列举了Set-Cookie的字段值</p>
<p>|属性|说明<br>|——<br>|NAME&#x3D;VALUE|赋予Cookie的名称和其值<br>|expires&#x3D;DATE|Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）<br>|path&#x3D;PATH|将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）<br>|domain&#x3D;域名|作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）<br>|Secure|仅在HTTPS安全通信时才会发送Cookie<br>|HttpOnly|加以限制，使Cookie不能被JavaScript脚本访问</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie:status=enable</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E9%A6%96%E9%83%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：HTTP首部（二）"><a href="#原创：HTTP首部（二）" class="headerlink" title="原创：HTTP首部（二）"></a>原创：HTTP首部（二）</h1><h1 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h1><p>请求首部字段是从客户端往服务端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<h2 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h2><p>Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用type&#x2F;subtype这种形式，一次指定多种媒体类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下为常见的几种媒体类型：</p>
<h2 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5,unicode-1-1;q=0.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段Accept相同的是可用权重q值来表示相对优先级。<br/><br>该首部字段应用于内容协商机制的服务器驱动协商。</p>
<h2 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码以及内容编码的优先级顺序。可一次性指定多种内容编码。<br/><br>以下列出几种常见的内容编码格式：</p>
<h2 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language:zh-cn,zh;q=0.7,en-us,en;q=0.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Accept-Language用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。<br/><br>上例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。</p>
<h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authorization:Basic   dWVub3N1bjpwYXnZD29Yza==</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Authorization是用来告知服务器，用户代理的认证信息（证书值）。<br/><br>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回验证要求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">401  Unauthorized</span><br><span class="line">WWW-Authenticated:Basic ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送认证信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm</span><br><span class="line">Authorization:Basic   dWVub3N1bjpwYXnZD29Yza==</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Except"><a href="#Except" class="headerlink" title="Except"></a>Except</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Except:100-continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端使用首部字段Except来告知服务器，期望出现的某种特定行为。</p>
<h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">From:info@hackr.jp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。</p>
<h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host:www.baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟主机运行在同一个IP上，此时使用首部字段Host加以区分。<br/><br>Host首部字段在HTTP&#x2F;1.1规范内是唯一一个必须被包含在请求内的首部字段。</p>
<h2 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.html</span><br><span class="line">If-Match:&quot;123456&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。<br/><br>实体标记（ETag）是与特定资源关联的确定值。资源更新后ETag也会随之更新。</p>
<h2 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h2><p>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  /index.htm</span><br><span class="line">If-Modified-Since:Thu,15  Apr   2004  00:00:00  GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若资源在2004年4月15日 之后更新过，则返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200  OK</span><br><span class="line">Last-Modified:Sun,29  Aug  2004  14:03:05  GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若资源在2004年4月15日之后没更新过，则返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">304   Not  Modified</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h2><p>请求报文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUT  /sample.html</span><br><span class="line">If-None-Match:  *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若没有匹配的ETag,则返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200  OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只有在If-None-Match的字段值与ETag值不一致时，可处理该请求。与If-Match首部字段的作用相反。</p>
<h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><p>该首部字段告知服务器若指定的If-Range字段值（ETag值或时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。<br/><br>尤其是在不匹配的情况下，节省了请求资源，无需重新发送请求，如果是If-Match则需要重新发送请求来获取最新的资源。</p>
<h2 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since:Thu,03  Jul  2012  00:00:00  GMT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。</p>
<h2 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max-Forwards:10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。<br/><br>服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应。<br/><br>Max-Forwards也可以用来观察以某台服务器为终点的传输路径的通信状况。</p>
<h2 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic    dG1w0jkpNLGAFDFIJ</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证锁需要的信息。<br/><br>该认证发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range:bytes=5001-10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面示例表示请求获取从第5001字节至第10000字节的资源。<br/><br>接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应。无法处理该范围请求时，则会返回状态码200 OK的响应及全部资源。</p>
<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET   /</span><br><span class="line">Referer:http://www.hackr.jp/index.htm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段Referer会告知服务器请求的原始资源的URI.<br/><br>客户端一般都会发送Referer首部字段给服务器。</p>
<h2 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TE:gzip,deflate；q=0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段Accept-Encoding的功能很像，但是用于传输编码。</p>
<h2 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：HTTP报文内的HTTP信息"><a href="#原创：HTTP报文内的HTTP信息" class="headerlink" title="原创：HTTP报文内的HTTP信息"></a>原创：HTTP报文内的HTTP信息</h1><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。<br/><br>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常不一定要有报文主体。</p>
<p>|报文首部<br>|——<br>|空行（CR+LF）<br>|报文主体</p>
<p>请求报文和响应报文的首部内容由如下内容组成：<br/><br>1.请求行<br/><br>包含用于请求的方法，请求URI和HTTP版本<br/><br>2.状态行<br/><br>包含表明响应结果的状态码，原因短语和HTTP版本<br/><br>3.首部字段<br/><br>包含表示请求和响应的各种条件和属性的各类首部<br/><br>一般有4种首部，分别是通用首部、请求首部、响应首部和实体首部</p>
<h1 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h1><p>HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速率。<br/><br>压缩传输的内容编码：<br/><br>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br/><br>常用的内容编码有以下几种：</p>
<p>分割发送的分块传输编码：<br/><br>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面<br/><br>HTTP&#x2F;1.1中存在一种称为传输编码的机制，它可以在通信时按某种编码方式传输，但只作用于分块传输编码中</p>
<h1 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h1><p>  发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions ,多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。<br/><br>在MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。<br/><br>HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。<br/><br>多部分对象集合包含的对象如下：</p>
<h1 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h1><p>针对断点续传的问题，可以通过指定下载的实体范围来解决<br/><br>执行范围请求时，会用到首部字段Range来指定资源的byte范围。<br/><br>byte范围的指定形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-3000,5000~7000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文<br/><br>如果服务端无法响应范围请求，则会返回状态码200，和完整的实体内容</p>
<h1 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h1><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。<br/><br>内容协商会以语言、字符集、编码方式等为基准判断响应的资源<br/><br>包含在请求报文中的某些首部字段就是判断基准：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-Gradle%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99-%20Could%20not%20find%20method%20leftShift()%20for%20arguments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-Gradle%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99-%20Could%20not%20find%20method%20leftShift()%20for%20arguments/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：Gradle构建项目报错：-Could-not-find-method-leftShift-for-arguments"><a href="#原创：Gradle构建项目报错：-Could-not-find-method-leftShift-for-arguments" class="headerlink" title="原创：Gradle构建项目报错： Could not find method leftShift() for arguments"></a>原创：Gradle构建项目报错： Could not find method leftShift() for arguments</h1><h1 id="build-gradle文件内容"><a href="#build-gradle文件内容" class="headerlink" title="build.gradle文件内容"></a>build.gradle文件内容</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task hello &amp;lt;&amp;lt; &#123;</span><br><span class="line">	println &quot;Hello World!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行gradle build,报错Could not find method leftShift() for arguments</p>
<h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><p>其中 &lt;&lt; 在gradle 在5.1 之后废弃了  ，可以通<code>gradle -v</code>来查看版本号</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>去掉<code>&amp;lt;&amp;lt;</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task hello &amp;lt;&amp;lt; &#123;</span><br><span class="line">	println &quot;Hello World!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-git%20add%20%E6%92%A4%E9%94%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-git%20add%20%E6%92%A4%E9%94%80/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：git-add-撤销"><a href="#原创：git-add-撤销" class="headerlink" title="原创：git add 撤销"></a>原创：git add 撤销</h1><p>git add 添加 多余文件<br/><br>这样的错误是由于， 有的时候 可能</p>
<p>git add . （空格+ 点） 表示当前目录所有文件，不小心就会提交其他文件</p>
<p>git add 如果添加了错误的文件的话</p>
<p>撤销操作</p>
<p>git status 先看一下add 中的文件<br/><br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br/><br>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：365-水壶问题"><a href="#原创：365-水壶问题" class="headerlink" title="原创：365.水壶问题"></a>原创：365.水壶问题</h1><p>来源：力扣（LeetCode）<br/><br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/water-and-jug-problem">https://leetcode-cn.com/problems/water-and-jug-problem</a></p>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<p>装满任意一个水壶<br/><br>清空任意一个水壶<br/><br>从一个水壶向另外一个水壶倒水，直到装满或者倒空<br/><br>示例 1: (From the famous “Die Hard” example)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        if(x+y&amp;lt;z)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x == 0 || y == 0)&#123;</span><br><span class="line">            return z==0 || x+y==z;</span><br><span class="line">        &#125;</span><br><span class="line">        return z % gcb(x,y) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int gcb(int m, int n) &#123;  </span><br><span class="line">            if (m &amp;lt; n) &#123;// 保证m&amp;gt;n,若m&amp;lt;n,则进行数据交换  </span><br><span class="line">                int temp = m;  </span><br><span class="line">                m = n;  </span><br><span class="line">                n = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (m % n == 0) &#123;// 若余数为0,返回最大公约数  </span><br><span class="line">                return n;  </span><br><span class="line">            &#125; else &#123; // 否则,进行递归,把n赋给m,把余数赋给n  </span><br><span class="line">                return gcb(n, m % n);  </span><br><span class="line">            &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>贝祖定理：<br/><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
