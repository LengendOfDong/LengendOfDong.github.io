<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lengendofdong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lengendofdong.github.io/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lengendofdong.github.io/page/13/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="history fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="list fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-tools"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/" rel="section"><i class="briefcase fa-fw"></i>tools</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/1.webp">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/java%E4%BD%BF%20FileWriter%20FileReader%20%E6%97%A0%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%EF%BC%8COutputStreamWriter%20InputStreamReader%E5%8F%AF%E8%AE%BE%E7%BD%AE%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/java%E4%BD%BF%20FileWriter%20FileReader%20%E6%97%A0%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%EF%BC%8COutputStreamWriter%20InputStreamReader%E5%8F%AF%E8%AE%BE%E7%BD%AE%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java使-FileWriter-FileReader-无编码格式，OutputStreamWriter-InputStreamReader可设置编码格式"><a href="#java使-FileWriter-FileReader-无编码格式，OutputStreamWriter-InputStreamReader可设置编码格式" class="headerlink" title="java使 FileWriter FileReader 无编码格式，OutputStreamWriter InputStreamReader可设置编码格式"></a>java使 FileWriter FileReader 无编码格式，OutputStreamWriter InputStreamReader可设置编码格式</h1><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/72730796">https://blog.csdn.net/qq_27093465/article/details/72730796</a></p>
<p>使用Java中的 FileWriter FileReader 可以传个文件路径，然后就可以简单的实现，文件的读和写。<br/><br>但是这个实现是太简单了，会有问题的。</p>
<p>简单的代码操作，如我的这篇博文里面的转存文件的代码就是使用这2个类来实现的。</p>
<p>java修改文件名-renameTo()方法的使用实例，复制一个文件或者叫转存一个文件</p>
<p>上面的转存代码，经过findbugs分析，有如下的提示：</p>
<p>具体如下：<br/><br>Found reliance on default encoding: new java.io.FileWriter(String)<br/><br>Reliance on default encoding<br/><br>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.</p>
<p>然后，翻译一下就是下图：</p>
<p>FileWriter FileReader 是不带编码格式的，默认使用本机器的默认编码，那么就会因为编码问题，而bug的。</p>
<p>怎么让 FileWriter FileReader 他们带上编码格式呢？</p>
<p>还是拿转存文件的代码来修改。具体修改如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static boolean copyFile(String src, String des) &#123;</span><br><span class="line">    InputStreamReader fr = null;</span><br><span class="line">    OutputStreamWriter fw = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        fr = new InputStreamReader(new FileInputStream(src),&quot;UTF-8&quot;);//读</span><br><span class="line">        fw = new OutputStreamWriter(new FileOutputStream(des), &quot;UTF-8&quot;);//写</span><br><span class="line">        char[] buf = new char[1024];//缓冲区</span><br><span class="line">        int len;</span><br><span class="line">        while ((len = fr.read(buf)) != -1) &#123;</span><br><span class="line">            fw.write(buf, 0, len);//读几个写几个</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(e.getMessage());</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (fr != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                LOG.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fw.flush();</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                LOG.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点就是把<br/><br>FileWriter FileReader   换成了  OutputStreamWriter InputStreamReader</p>
<p>new InputStreamReader(new FileInputStream(src),“UTF-8”);&#x2F;&#x2F;读<br/><br>new OutputStreamWriter(new FileOutputStream(des), “UTF-8”);&#x2F;&#x2F;写</p>
<p>这就带上了编码格式了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/Java8%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/Java8%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java8中的默认方法"><a href="#Java8中的默认方法" class="headerlink" title="Java8中的默认方法"></a>Java8中的默认方法</h1><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>  Java8中加入默认方法主要是为了支持库设计师，让他们能够写出容易改进的接口。这一方法很重要，因为你会在接口中遇到越来越多的默认方法，但由于真正需要编写默认方法的程序员相对较少，而且它们只是有助于程序改进，而不是用于编写任何具体的程序。<br/><br>  两段Java8示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Apple&amp;gt; heavyApples1 =</span><br><span class="line">	inventory.stream().filter((Apple a) -&amp;gt; a.getWeight() &amp;gt; 50).collect(toList());</span><br><span class="line">List&amp;lt;Apple&amp;gt; heavyApples2 = </span><br><span class="line">    inventory.parallelStream().filter((Apple a) -&amp;gt; a.getWeight() &amp;gt; 50).collect(toList())	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但这里有个问题：在Java8之前，List并没有stream或者parallelStream方法，它实现的Collection接口也没有。可没有这些方法，这些代码就不能编译。最简单的方法就是在Collection接口中加入stream方法，并加入ArrayList类的实现。<br/><br>  可要是这样做，对用户来说就是噩梦了。有很多的替代集合框架都用Collection API实现了接口。但给接口加入一个新方法，意味着所有的实体类都必须为其提供一个实现。语言设计者没法控制Collections所有现有的实现，所以如何改变已发布的接口而不破坏已有的实现呢？<br/><br>  Java8的解决办法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名了。缺失的方法主体随接口提供了，而不是由实现类提供。<br/><br>  这就给接口设计者提供了一个扩充接口的方式，而不会破坏现有的代码。Java 8在接口声明中使用新的<strong>default</strong>关键字来表示这一点。<br/><br>  例如，在Java 8里，现在可以直接对List用sort方法。它是用Java8 List接口中如下所示的默认方法实现的，它会调用Collections.sort静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default void sort(Comparator&amp;lt;? super E&amp;gt; c)&#123;</span><br><span class="line">	Collections.sort(this,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  这意味着List的任何实体类都不需要显式实现sort,而在以前的Java版本中，除非提供了sort的实现，否则这些实体类在重新编译时都会失败。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/Java8%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/Java8%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java8用流收集数据"><a href="#Java8用流收集数据" class="headerlink" title="Java8用流收集数据"></a>Java8用流收集数据</h1><h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><h3 id="统计总数"><a href="#统计总数" class="headerlink" title="统计总数"></a>统计总数</h3><p>利用收集器来统计菜单中有多少中菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long howManyDishes = menu.stream().collect(Collectors.counting());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h3><p>可以使用两个收集器，Collectors.maxBy和Collectors.minBy,来计算流中的最大值和最小值。这两个收集器接收一个Comparator参数来比较流中的元素。可以创建一个Comparator来根据所含热量对菜肴进行比较，并把它传递给Collectors.maxBy:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&amp;lt;Dish&amp;gt; dishCaloriesComparator = </span><br><span class="line">	Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&amp;lt;Dish&amp;gt; mostCaloriesDish = </span><br><span class="line">	menu.stream().collect(maxBy(dishCaloriesComparator))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。它可接收一个把对象映射为求和所需Int的函数，并返回一个收集器;该收集器在传递给普通的collect方法后即执行我们所需要的汇总操作。举个例子，可以这样求出菜单列表的总热量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，汇总不仅仅是求和：还有Collectors.averagingInt，连同对应的averagingLong和averagingDouble可以计算数值的平均数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double avgCalories = </span><br><span class="line">	menu.stream().collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过一次summerizing操作就可以数出菜单中元素的个数，并得到菜肴热量总和、平均值、最大值和最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics = </span><br><span class="line">	menu.stream().collect(summarizingInt(Dish::getCalories));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印menuStaticsticObject会得到：<br/><br>IntSummaryStatistics{count&#x3D;9,sum&#x3D;4300,min&#x3D;120,average&#x3D;477.77778,max&#x3D;800}</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。可以使用这种方法，把菜单中的菜肴名称都连接起来，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName()).collect(joining());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>joining在内部使用了StringBuilder来把生成的字符串逐个追加起来。<br/><br>如果Dish类本身就有一个toString方法来返回菜肴的名称，可以使用下面方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过使用joining工厂方法的一个重载版本，可以得到一个逗号分隔的菜肴名称列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining(&quot;,&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>假如要把菜单中的菜按照类型进行分类，有肉的放一组，有鱼的放一组，其他的都放另一组。用Collectors.groupingBy工厂方法返回的收集器就可以轻松完成这项任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Dish.Type,List&amp;lt;Dish&amp;gt;&amp;gt; dishesByType = </span><br><span class="line">	menu.stream().collect(groupingBy(Dish::getType));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为下面的Map:<br/><br>{FISH&#x3D;[prawns,salmon],OTHER&#x3D;[french fries,rice,season fruit,pizza],MEAT&#x3D;[pork,beef,chicken]}</p>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><p>要实现多级分组，可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum CaloricLevel(DIET,NORMAL,FAT&#125;</span><br><span class="line">Map&amp;lt;Dish.Type,Map&amp;lt;CaloricLevel,List&amp;lt;Dish&amp;gt;&amp;gt;&amp;gt; dishesByTypeCaloricLevel =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    	groupingBy(Dish::getType,</span><br><span class="line">    		groupingBy(dish -&amp;gt; &#123;</span><br><span class="line">    			if (dish.getCalories() &amp;lt;= 400) return CaloricLevel.DIET;</span><br><span class="line">    			else if(dish.getCalories() &amp;lt;=700) return CaloricLevel.NORMAL;</span><br><span class="line">    			else return CaloricLevel.FAT;</span><br><span class="line">    			&#125;)</span><br><span class="line">    		)</span><br><span class="line">    	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外groupingBy和其他收集器联合使用也可以，例如groupingBy和mapping收集器结合起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Dish.Type,Set&amp;lt;CaloricLevel&amp;gt;&amp;gt; caloricLevelByType = </span><br><span class="line">	menu.stream().collect(</span><br><span class="line">		groupingBy(Dish::getType,mapping(</span><br><span class="line">			dish-&amp;gt; &#123; if (dish.getCalories() &amp;lt;= 400 ) return CaloricLevel.DIET;</span><br><span class="line">			else if (dish.getCalories() &amp;lt;= 700 ) return CaloricLevel.NORMAL;</span><br><span class="line">			else return CaloricLevel.FAT;</span><br><span class="line">			&#125;,toSet()</span><br><span class="line">			)</span><br><span class="line">		) </span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，称为分区函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&amp;lt;Boolean,List&amp;lt;Dish&amp;gt;&amp;gt; partitionedMenu =</span><br><span class="line">	menu.stream().collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到partitioningBy(Dish::isVegetarian)和groupingBy(Dish::getType)很相似，就是返回的类型不一样罢了。<br/><br>找出所有的素食菜肴，利用get方法获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianDishes = partitionedMenu.get(true);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用下面的方法也可以获得同样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianDishes = menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/Java8%E6%95%B0%E5%80%BC%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/Java8%E6%95%B0%E5%80%BC%E6%B5%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java8数值流"><a href="#Java8数值流" class="headerlink" title="Java8数值流"></a>Java8数值流</h1><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>背景：<br/><br>当计算菜单的热量时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int calories = menu.stream().map(Dish::getCalories).reduce(0,Integer::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：<br/><br>上例中暗含了装箱的成本，每个Integer都必须拆箱成一个原始类型，再进行求和。</p>
<p>解决方法：<br/><br>Java8中引入了三个原始类型特化流接口来解决这个问题：IntStream,DoubleStream和LongStream，分别将流中的元素特化为int,long和double，从而避免了暗含的装箱成本。<br/><br>1.映射到数值流<br/><br>将流转换为特化版本的常用方法时mapToInt，mapToDouble和mapToLong。这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream。例如，可以用mapToInt对menu中的卡路里求和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int calories  = menu.stream().mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.转换回对象流<br/><br>同样，一旦有了数值流，你可能会想把它转换回非特化流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&amp;lt;Integer&amp;gt; stream = intStream.boxed();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.默认值OptionalInt<br/><br>Optional可以用Integer，String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt,OptionalDouble和OptionalLong。</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>Java8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。例如选出1到100中的偶数个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.rangeClosed(1,100).filter(n -&amp;gt; n % 2 == 0);</span><br><span class="line">System.out.println(evenNumbers.count());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例的结果返回的是50，rangeClosed是算上结束值的。<br/><br>如果改用IntStream.range(1,100),则结果将会是49个偶数，因为range是不包含结束值的。</p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>可以使用静态方法Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。例如，下面的代码直接使用Stream.of创建一个字符串流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;Java 8&quot;,&quot;Lambda&quot;,&quot;In &quot;,&quot;Action&quot;);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，还可以使用empty得到一个空流，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&amp;lt;String&amp;gt; emptyStream = Stream.empty();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><p>可以使用静态方法Arrays.stream从数组创建一个流，接受一个数组作为参数。例如，可以将一个原始类型int的数组转换成一个IntStream,如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;2,3,5,7,11,13&#125;;</span><br><span class="line">int sum = Arrays.stream(numbers).sum();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="从文件生成流"><a href="#从文件生成流" class="headerlink" title="从文件生成流"></a>从文件生成流</h3><p>Java中用于处理文件等I&#x2F;O操作的NIO api已更新，以便利用Stream api。java.nio.file.Files中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines,它会返回一个由指定文件中的各行构成的字符串流。例如下面的例子中查看一个文件中有多少个不相同的词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long uniqueWords = 0;</span><br><span class="line">try(Stream&amp;lt;String&amp;gt; lines = </span><br><span class="line">		Files.lines(Paths.get(&quot;data.txt&quot;),Charset.defaultCharset()))&#123;</span><br><span class="line">	uniqueWords = lines.flatMap( line -&amp;gt; Arrays.stream(line.split(&quot; &quot;)))</span><br><span class="line">			.distinct().count()</span><br><span class="line">	)</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate.这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。一般来说，应该使用limit(n)来对这种流加以限制，以避免打印无穷多个值。<br/><br>1.迭代</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(0,n -&amp;gt; n + 2）.limit(10).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中每次生成的值都作为下次循环的参数，初始值为0，每次迭代增加2，2，4，6，8…<br/><br>2.生成<br/><br>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数 的。它接受一个Supplier类型的Lambda提供新的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">		.limit(5).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/Java8%E4%BD%BF%E7%94%A8%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/Java8%E4%BD%BF%E7%94%A8%E6%B5%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java8使用流"><a href="#Java8使用流" class="headerlink" title="Java8使用流"></a>Java8使用流</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><h3 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h3><p>Stream接口支持filter方法。该操作会接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。例如筛选出菜单中所有的素菜，创建一张素食菜单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><p>  流还支持一个叫做distinct的方法，它会返回一个元素各异的流。例如，筛选出列表中所有的偶数，并确保没有重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1,2,1,3,3,2,4);</span><br><span class="line">numbers.stream().filter(i -&amp;gt; i % 2 == 0 ).distinct().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="截短流"><a href="#截短流" class="headerlink" title="截短流"></a>截短流</h3><p>  流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。比如，建立一个List，选出热量超过300卡路里的头三道菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; dishes = menu.stream().filter(d -&amp;gt; d.getCalories() &amp;gt; 300).limit(3).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：limit也可以用在无序流上，比如源是一个Set。在这种情况下，limit的结果不会以任何顺序排列。</p>
<h3 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h3><p>  流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。<br/><br><strong>注意</strong>:limit(n)和skip(n)是互补的，例如，下面的代码将跳过超过300卡路里的头两道菜，并返回剩下的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Dish&amp;gt; dishes = menu.stream().filter(d -&amp;gt; d.getCalories() &amp;gt; 300 ).skip(2).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>  一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具。</p>
<h3 id="对流中每一个元素应用函数"><a href="#对流中每一个元素应用函数" class="headerlink" title="对流中每一个元素应用函数"></a>对流中每一个元素应用函数</h3><p>  流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是”创建一个新版本“而不是去”修改“)。例如，下面的代码把方法引用Dish::getName传给了map方法，来提取流中菜肴的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;String&amp;gt; dishNames =  menu.stream().map(Dish::getName).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要找出每道菜的名称有多长，怎么做？可以如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; dishNameLengths = menu.stream().map(Dish::getName).map(String::length).collect(toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一步是获取流中的菜肴名称，然后再获取菜肴名称的长度，返回一个List</p>
<h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>  对于一张单词表，如何返回一张列表，列出里面各不相同的字符呢？例如，给定单词列表[“Hello”,“World”],你想要返回列表[“H”,“e”,“l”,“o”,“W”,“r”,“d”]。<br/><br>可以使用flatMap来达到目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;String&amp;gt; uniqueCharacters = words.stream().map(w -&amp;gt; w.split(&quot;&quot;)).flatMap(Arrays::stream).distinct().collect(Collections.toList())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容（数组中的内容映射出来，形成一个流的内容，实现了流的合并）。所有使用map(Arrays::stream)时生成的单个流都被合并起来，扁平化为一个流。<br/><br>总之，flatMap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p>
<h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><p>  另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch,anyMatch,noneMatch,findFirst和findAny方法提供了这样的工具。</p>
<h3 id="检查谓词是否至少匹配一个元素"><a href="#检查谓词是否至少匹配一个元素" class="headerlink" title="检查谓词是否至少匹配一个元素"></a>检查谓词是否至少匹配一个元素</h3><p>anyMatch方法可以回答”流中是否有一个元素能匹配给定的谓词“。比如，你可以用它来看看菜单里面是否有素食可选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if （menu.stream().anyMatch(Dish::isVegetarian)）&#123;</span><br><span class="line">	System.out.println(&quot;The menu is vegetarian friendly!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查谓词是否匹配所有元素"><a href="#检查谓词是否匹配所有元素" class="headerlink" title="检查谓词是否匹配所有元素"></a>检查谓词是否匹配所有元素</h3><p>使用allMatch检查菜品的热量是否都小于1000卡路里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean isHealthy = menu.stream().allMatch(d -&amp;gt; d.getCalories() &amp;lt; 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与此相对的是noneMatch，可以重写上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean isHealthy = menu.stream().noneMatch(d -&amp;gt; d.getCalories() &amp;gt;= 1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用。可以结合使用filter和findAny方法来实现查询素食菜肴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Dish&amp;gt; dish = menu.stream().filter(Dish::isVegetarian).findAny();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h3><p>  有些流有一个出现顺序来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。给定一个数字列表，下面的代码能找出第一个平方能被3整除的数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&amp;lt;Integer&amp;gt; someNumbers = Arrays.aslist(1,2,3,4,5);</span><br><span class="line">Optional&amp;lt;Integer&amp;gt; firstSquareDivisibleByThree = </span><br><span class="line">		someNumbers.stream().map(x -&amp;gt; x * x).filter(x -&amp;gt; x % 3 == 0)</span><br><span class="line">					.findFirst();//9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：何时使用findFirst和findAny<br/><br>找到第一个元素在并行上限制更多，如果不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制更少。</p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><h3 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h3><p>对元素求和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,(a,b) -&amp;gt; a + b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变形后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,(a,b) -&amp;gt; Integer.sum(a,b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再进一步变形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0,Integer::sum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于无初始值的情况：<br/><br>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; sum = numbers.stream().reduce((a,b) -&amp;gt; a + b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当流中没有任何元素是，reduce操作无法返回其和，因为它没有初始值。这就是为什么包裹在一个Optional对象里，以表明和可能不存在。</p>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>计算最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&amp;lt;Integer&amp;gt; min = numbers.stream().reduce(Integer::min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算流中个数：<br/><br>方法一：int count &#x3D; menu.stream().map(d -&gt; 1).reduce(0,(a,b) -&gt; a + b);<br/><br>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。<br/><br>方法二：long count &#x3D; menu.stream().count();</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/git%20add%20%E6%92%A4%E9%94%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/git%20add%20%E6%92%A4%E9%94%80/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="git-add-撤销"><a href="#git-add-撤销" class="headerlink" title="git add 撤销"></a>git add 撤销</h1><p>git add 添加 多余文件<br/><br>这样的错误是由于， 有的时候 可能</p>
<p>git add . （空格+ 点） 表示当前目录所有文件，不小心就会提交其他文件</p>
<p>git add 如果添加了错误的文件的话</p>
<p>撤销操作</p>
<p>git status 先看一下add 中的文件<br/><br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br/><br>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365.水壶问题"></a>365.水壶问题</h1><p>来源：力扣（LeetCode）<br/><br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/water-and-jug-problem">https://leetcode-cn.com/problems/water-and-jug-problem</a></p>
<p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<p>装满任意一个水壶<br/><br>清空任意一个水壶<br/><br>从一个水壶向另外一个水壶倒水，直到装满或者倒空<br/><br>示例 1: (From the famous “Die Hard” example)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 3, y = 5, z = 4</span><br><span class="line">输出: True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: x = 2, y = 6, z = 5</span><br><span class="line">输出: False</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        if(x+y&amp;lt;z)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x == 0 || y == 0)&#123;</span><br><span class="line">            return z==0 || x+y==z;</span><br><span class="line">        &#125;</span><br><span class="line">        return z % gcb(x,y) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int gcb(int m, int n) &#123;  </span><br><span class="line">            if (m &amp;lt; n) &#123;// 保证m&amp;gt;n,若m&amp;lt;n,则进行数据交换  </span><br><span class="line">                int temp = m;  </span><br><span class="line">                m = n;  </span><br><span class="line">                n = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (m % n == 0) &#123;// 若余数为0,返回最大公约数  </span><br><span class="line">                return n;  </span><br><span class="line">            &#125; else &#123; // 否则,进行递归,把n赋给m,把余数赋给n  </span><br><span class="line">                return gcb(n, m % n);  </span><br><span class="line">            &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>贝祖定理：<br/><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>方法一：暴力法<br/><br>复杂度分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SolutionOne &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target)&#123;</span><br><span class="line">        for( int i = 0; i&amp;lt; nums.length ; i++)&#123;</span><br><span class="line">            for (int j = i+ 1; j &amp;lt; nums.length ; j++)&#123;</span><br><span class="line">                if (nums[j] == target - nums[i])&#123;</span><br><span class="line">                    return new int[]&#123;i ,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：一遍哈希表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SolutionTwo &#123;</span><br><span class="line">    public  int[] twoSum(int[] nums, int target)&#123;</span><br><span class="line">        Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();</span><br><span class="line">        for(int i = 0; i &amp;lt; nums.length ; i++)&#123;</span><br><span class="line">            int complement = target - nums[i];</span><br><span class="line">            if(map.containsKey(complement))&#123;</span><br><span class="line">                return new int[]&#123;map.get(complement),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw  new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/[%E8%BD%AC%E8%BD%BD]%E5%B0%8F%E7%99%BD%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%EF%BC%8C%E8%BF%9E%E7%BB%AD%E5%88%B7%E9%A2%98%E4%B8%89%E5%B9%B4%EF%BC%8C%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%5B%E8%BD%AC%E8%BD%BD%5D%E5%B0%8F%E7%99%BD%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%EF%BC%8C%E8%BF%9E%E7%BB%AD%E5%88%B7%E9%A2%98%E4%B8%89%E5%B9%B4%EF%BC%8C%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转载-小白一路走来，连续刷题三年，谈谈我的算法学习经验"><a href="#转载-小白一路走来，连续刷题三年，谈谈我的算法学习经验" class="headerlink" title="[转载]小白一路走来，连续刷题三年，谈谈我的算法学习经验"></a>[转载]小白一路走来，连续刷题三年，谈谈我的算法学习经验</h1><p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kubidemanong/p/10996134.html">小白一路走来，连续刷题三年，谈谈我的算法学习经验</a><br/><br>说得很中肯，值得推荐</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/[%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7]%E6%89%BE%E5%87%BA%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%5B%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7%5D%E6%89%BE%E5%87%BA%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="解题技巧-找出没有重复的数"><a href="#解题技巧-找出没有重复的数" class="headerlink" title="[解题技巧]找出没有重复的数"></a>[解题技巧]找出没有重复的数</h1><p>题目：<br/><br>给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。<br/><br>数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,4,3,2,1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用异或方式解题：</p>
<p>解题思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1^2^3^4^5^4^3^2^1  = (1^1)^(2^2)^(3^3)^(4^4)^5 = 0^0^0^0^5 = 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int findNum(int[] array)&#123;</span><br><span class="line">       int tmp = 0;</span><br><span class="line">       for(int num : array)&#123;</span><br><span class="line">           tmp = tmp^num;</span><br><span class="line">       &#125;</span><br><span class="line">       return tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为O(1)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
