<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lengendofdong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lengendofdong.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lengendofdong.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-Java%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E8%BD%AC%E8%BD%BD-Java%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转载：Java-中的异常和处理详解"><a href="#转载：Java-中的异常和处理详解" class="headerlink" title="转载：Java 中的异常和处理详解"></a>转载：Java 中的异常和处理详解</h1><h2 id="原文出处：-代码钢琴家"><a href="#原文出处：-代码钢琴家" class="headerlink" title="原文出处： 代码钢琴家"></a>原文出处： <a target="_blank" rel="noopener" href="http://www.cnblogs.com/lulipro/p/7504267.html">代码钢琴家</a></h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。异常发生时，是任程序自生自灭，立刻退出终止，还是输出错误给用户？或者用C语言风格：用函数返回值作为执行状态？。</p>
<p>Java提供了更加优秀的解决办法：异常处理机制。</p>
<p>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。<br/><br>Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</p>
<p>Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p>
<h2 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h2><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p>
<p>非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p>
<p>检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
<p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</p>
<h2 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h2><p>下面的代码会演示2个异常类型：ArithmeticException 和 InputMismatchException。前者由于整数除0引发，后者是输入的数据不能被转换为int类型引发。<br>|1234567891011121314151617181920212223242526272829303132333435363738394041|<code>package</code> <code>com.example;``import</code> <code>java. util .Scanner ;``public</code> <code>class</code> <code>AllDemo``&#123;``      ``public</code> <code>static</code> <code>void</code> <code>main (String [] args )``      ``&#123;``            ``System . out. println( ``&quot;----欢迎使用命令行除法计算器----&quot;</code> <code>) ;``            ``CMDCalculate ();``      ``&#125;``      ``public</code> <code>static</code> <code>void</code> <code>CMDCalculate ()``      ``&#123;``            ``Scanner scan = ``new</code> <code>Scanner ( System. in );``            ``int</code> <code>num1 = scan .nextInt () ;``            ``int</code> <code>num2 = scan .nextInt () ;``            ``int</code> <code>result = devide (num1 , num2 ) ;``            ``System . out. println( ``&quot;result:&quot;</code> <code>+ result) ;``            ``scan .close () ;``      ``&#125;``      ``public</code> <code>static</code> <code>int</code> <code>devide (``int</code> <code>num1, ``int</code> <code>num2 )&#123;``            ``return</code> <code>num1 / num2 ;``      ``&#125;``&#125;``/*****************************************</code> <code>----欢迎使用命令行除法计算器----``0``Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero``     ``at com.example.AllDemo.devide( AllDemo.java:30 )``     ``at com.example.AllDemo.CMDCalculate( AllDemo.java:22 )``     ``at com.example.AllDemo.main( AllDemo.java:12 )</code> <code>----欢迎使用命令行除法计算器----``r``Exception in thread &quot;main&quot; java.util.InputMismatchException``     ``at java.util.Scanner.throwFor( Scanner.java:864 )``     ``at java.util.Scanner.next( Scanner.java:1485 )``     ``at java.util.Scanner.nextInt( Scanner.java:2117 )``     ``at java.util.Scanner.nextInt( Scanner.java:2076 )``     ``at com.example.AllDemo.CMDCalculate( AllDemo.java:20 )``     ``at com.example.AllDemo.main( AllDemo.java:12 )``*****************************************/</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p>34</p>
<p>36</p>
<p>38</p>
<p>40</p>
<p><code>package</code> <code>com.example;</code></p>
<p><code>public</code> <code>class</code> <code>AllDemo</code></p>
<p><code>      ``public</code> <code>static</code> <code>void</code> <code>main (String [] args )</code></p>
<p><code>            ``System . out. println( ``&quot;----欢迎使用命令行除法计算器----&quot;</code> <code>) ;</code></p>
<p><code>      ``&#125;</code></p>
<p><code>      ``&#123;</code></p>
<p><code>            ``int</code> <code>num1 = scan .nextInt () ;</code></p>
<p><code>            ``int</code> <code>result = devide (num1 , num2 ) ;</code></p>
<p><code>            ``scan .close () ;</code></p>
<p><code>      ``public</code> <code>static</code> <code>int</code> <code>devide (``int</code> <code>num1, ``int</code> <code>num2 )&#123;</code></p>
<p><code>      ``&#125;</code></p>
<p><code>/*****************************************</code></p>
<p><code>----欢迎使用命令行除法计算器----</code></p>
<p><code>Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero</code></p>
<p><code>     ``at com.example.AllDemo.CMDCalculate( AllDemo.java:22 )</code></p>
<p> </p>
<p><code>r</code></p>
<p><code>     ``at java.util.Scanner.throwFor( Scanner.java:864 )</code></p>
<p><code>     ``at java.util.Scanner.nextInt( Scanner.java:2117 )</code></p>
<p><code>     ``at com.example.AllDemo.CMDCalculate( AllDemo.java:20 )</code></p>
<p><code>*****************************************/</code></p>
<p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。</p>
<p>异常最先发生的地方，叫做异常抛出点。</p>
<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>
<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>
<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。<br>|123456789101112131415|<code>@Test``public</code> <code>void</code> <code>testException() ``throws</code> <code>IOException``&#123;``    ``//FileInputStream的构造函数会抛出FileNotFoundException``    ``FileInputStream fileIn = ``new</code> <code>FileInputStream(``&quot;E:\\a.txt&quot;``);</code> <code>    ``int</code> <code>word;``    ``//read方法会抛出IOException``    ``while``((word =  fileIn.read())!=-``1``) ``    ``&#123;``        ``System.out.print((``char``)word);``    ``&#125;``    ``//close方法会抛出IOException``    ``fileIn.clos``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p><code>@Test</code></p>
<p><code>&#123;</code></p>
<p><code>    ``FileInputStream fileIn = ``new</code> <code>FileInputStream(``&quot;E:\\a.txt&quot;``);</code></p>
<p><code>    ``int</code> <code>word;</code></p>
<p><code>    ``while``((word =  fileIn.read())!=-``1``) </code></p>
<p><code>        ``System.out.print((``char``)word);</code></p>
<p><code>    ``//close方法会抛出IOException</code></p>
<p><code>&#125;</code></p>
<h2 id="异常处理的基本语法"><a href="#异常处理的基本语法" class="headerlink" title="异常处理的基本语法"></a>异常处理的基本语法</h2><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：使用try…catch…finally语句块处理它。或者，在函数签名中使用throws 声明交给函数调用者caller去解决。</p>
<p>try…catch…finally语句块<br>|123456789101112131415161718192021|<code>try``&#123;``     ``//try块中放可能发生异常的代码。``     ``//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。``     ``//如果发生异常，则尝试去匹配catch块。</code> <code>&#125;``catch``(SQLException SQLexception)&#123;``    ``//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。``    ``//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。``    ``//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。``    ``//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。``    ``//如果try中没有发生异常，则所有的catch块将被忽略。</code> <code>&#125;``catch``(Exception exception)&#123;``    ``//...``&#125;``finally``&#123;</code> <code>    ``//finally块通常是可选的。``   ``//无论异常是否发生，异常是否匹配被处理，finally都会执行。``   ``//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。``  ``//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 ``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p><code>try``&#123;</code></p>
<p><code>     ``//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</code></p>
<p> </p>
<p><code>    ``//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</code></p>
<p><code>    ``//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</code></p>
<p><code>    ``//如果try中没有发生异常，则所有的catch块将被忽略。</code></p>
<p><code>&#125;``catch``(Exception exception)&#123;</code></p>
<p><code>&#125;``finally``&#123;</code></p>
<p><code>    ``//finally块通常是可选的。</code></p>
<p><code>   ``//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</code></p>
<p><code>&#125;</code></p>
<p><strong>需要注意的地方</strong></p>
<p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>
<p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p>
<p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br/><br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br/><br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）<br>|1234567891011|<code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)&#123;``        ``try</code> <code>&#123;``            ``foo();``        ``&#125;``catch``(ArithmeticException ae) &#123;``            ``System.out.println(``&quot;处理异常&quot;``);``        ``&#125;``&#125;``public</code> <code>static</code> <code>void</code> <code>foo()&#123;``        ``int</code> <code>a = ``5``/``0``;  ``//异常抛出点``        ``System.out.println(``&quot;为什么还不给我涨工资!!!&quot;``);  ``//////////////////////不会执行``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)&#123;</code></p>
<p><code>            ``foo();</code></p>
<p><code>            ``System.out.println(``&quot;处理异常&quot;``);</code></p>
<p><code>&#125;</code></p>
<p><code>        ``int</code> <code>a = ``5``/``0``;  ``//异常抛出点</code></p>
<p><code>&#125;</code></p>
<p>throws 函数声明</p>
<p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>
<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。<br>|1234|<code>public</code> <code>void</code> <code>foo() ``throws</code> <code>ExceptionType1 , ExceptionType2 ,ExceptionTypeN``&#123; ``     ``//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。``&#125;</code></p>
<p>2</p>
<p>4</p>
<p><code>&#123; </code></p>
<p><code>&#125;</code></p>
<h2 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h2><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p>
<p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p>
<p>需要注意的地方:</p>
<p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p>
<p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p>
<p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p>
<p>这是正常的情况，但是也有特例。关于finally有很多恶心，偏、怪、难的问题，我在本文最后统一介绍了，电梯速达-&gt;：finally块和return</p>
<h2 id="throw-异常抛出语句"><a href="#throw-异常抛出语句" class="headerlink" title="throw 异常抛出语句"></a>throw 异常抛出语句</h2><p>throw exceptionObject</p>
<p>程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。</p>
<p>throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。<br>|1234567|<code>public</code> <code>void</code> <code>save(User user)``&#123;``      ``if``(user  == ``null``) ``          ``throw</code> <code>new</code> <code>IllegalArgumentException(``&quot;User对象为空&quot;``);``      ``//......</code> <code>&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p><code>public</code> <code>void</code> <code>save(User user)</code></p>
<p><code>      ``if``(user  == ``null``) </code></p>
<p><code>      ``//......</code></p>
<p><code>&#125;</code></p>
<h2 id="异常的链化"><a href="#异常的链化" class="headerlink" title="异常的链化"></a>异常的链化</h2><p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。</p>
<p>异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p>
<p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。<br>|12345678910111213141516|<code>public</code> <code>class</code> <code>Throwable ``implements</code> <code>Serializable &#123;``    ``private</code> <code>Throwable cause = ``this``;</code> <code>    ``public</code> <code>Throwable(String message, Throwable cause) &#123;``        ``fillInStackTrace();``        ``detailMessage = message;``        ``this``.cause = cause;``    ``&#125;``     ``public</code> <code>Throwable(Throwable cause) &#123;``        ``fillInStackTrace();``        ``detailMessage = (cause==``null</code> <code>? ``null</code> <code>: cause.toString());``        ``this``.cause = cause;``    ``&#125;</code> <code>    ``//........``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p><code>    ``private</code> <code>Throwable cause = ``this``;</code></p>
<p><code>    ``public</code> <code>Throwable(String message, Throwable cause) &#123;</code></p>
<p><code>        ``detailMessage = message;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>        ``fillInStackTrace();</code></p>
<p><code>        ``this``.cause = cause;</code></p>
<p> </p>
<p><code>&#125;</code></p>
<p>下面是一个例子，演示了异常的链化：从命令行输入2个int，将他们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出</p>
<p>一个链化的异常。<br>|123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960|<code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)``&#123;</code> <code>    ``System.out.println(``&quot;请输入2个加数&quot;``);``    ``int</code> <code>result;``    ``try``    ``&#123;``        ``result = add();``        ``System.out.println(``&quot;结果:&quot;``+result);``    ``&#125; ``catch</code> <code>(Exception e)&#123;``        ``e.printStackTrace();``    ``&#125;``&#125;``//获取输入的2个整数返回``private</code> <code>static</code> <code>List&amp;lt;Integer&amp;gt; getInputNumbers()``&#123;``    ``List&amp;lt;Integer&amp;gt; nums = ``new</code> <code>ArrayList&amp;lt;&amp;gt;();``    ``Scanner scan = ``new</code> <code>Scanner(System.in);``    ``try</code> <code>&#123;``        ``int</code> <code>num1 = scan.nextInt();``        ``int</code> <code>num2 = scan.nextInt();``        ``nums.add(``new</code> <code>Integer(num1));``        ``nums.add(``new</code> <code>Integer(num2));``    ``&#125;``catch``(InputMismatchException immExp)&#123;``        ``throw</code> <code>immExp;``    ``&#125;``finally</code> <code>&#123;``        ``scan.close();``    ``&#125;``    ``return</code> <code>nums;``&#125;</code> <code>//执行加法计算``private</code> <code>static</code> <code>int</code> <code>add() ``throws</code> <code>Exception``&#123;``    ``int</code> <code>result;``    ``try</code> <code>&#123;``        ``List&amp;lt;Integer&amp;gt; nums =getInputNumbers();``        ``result = nums.get(``0``)  + nums.get(``1``);``    ``&#125;``catch``(InputMismatchException immExp)&#123;``        ``throw</code> <code>new</code> <code>Exception(``&quot;计算失败&quot;``,immExp);  ``/////////////////////////////链化:以一个异常对象为参数构造新的异常对象。``    ``&#125;``    ``return</code>  <code>result;``&#125;</code> <code>/*``请输入2个加数``r 1``java.lang.Exception: 计算失败``    ``at practise.ExceptionTest.add(ExceptionTest.java:53)``    ``at practise.ExceptionTest.main(ExceptionTest.java:18)``Caused by: java.util.InputMismatchException``    ``at java.util.Scanner.throwFor(Scanner.java:864)``    ``at java.util.Scanner.next(Scanner.java:1485)``    ``at java.util.Scanner.nextInt(Scanner.java:2117)``    ``at java.util.Scanner.nextInt(Scanner.java:2076)``    ``at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)``    ``at practise.ExceptionTest.add(ExceptionTest.java:48)``    ``... 1 more</code> <code>*/</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p>34</p>
<p>36</p>
<p>38</p>
<p>40</p>
<p>42</p>
<p>44</p>
<p>46</p>
<p>48</p>
<p>50</p>
<p>52</p>
<p>54</p>
<p>56</p>
<p>58</p>
<p>60</p>
<p><code>&#123;</code></p>
<p><code>    ``System.out.println(``&quot;请输入2个加数&quot;``);</code></p>
<p><code>    ``try</code></p>
<p><code>        ``result = add();</code></p>
<p><code>    ``&#125; ``catch</code> <code>(Exception e)&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>//获取输入的2个整数返回</code></p>
<p><code>&#123;</code></p>
<p><code>    ``Scanner scan = ``new</code> <code>Scanner(System.in);</code></p>
<p><code>        ``int</code> <code>num1 = scan.nextInt();</code></p>
<p><code>        ``nums.add(``new</code> <code>Integer(num1));</code></p>
<p><code>    ``&#125;``catch``(InputMismatchException immExp)&#123;</code></p>
<p><code>    ``&#125;``finally</code> <code>&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>&#125;</code></p>
<p><code>//执行加法计算</code></p>
<p><code>&#123;</code></p>
<p><code>    ``try</code> <code>&#123;</code></p>
<p><code>        ``result = nums.get(``0``)  + nums.get(``1``);</code></p>
<p><code>        ``throw</code> <code>new</code> <code>Exception(``&quot;计算失败&quot;``,immExp);  ``/////////////////////////////链化:以一个异常对象为参数构造新的异常对象。</code></p>
<p><code>    ``return</code>  <code>result;</code></p>
<p> </p>
<p><code>请输入2个加数</code></p>
<p><code>java.lang.Exception: 计算失败</code></p>
<p><code>    ``at practise.ExceptionTest.main(ExceptionTest.java:18)</code></p>
<p><code>    ``at java.util.Scanner.throwFor(Scanner.java:864)</code></p>
<p><code>    ``at java.util.Scanner.nextInt(Scanner.java:2117)</code></p>
<p><code>    ``at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)</code></p>
<p><code>    ``... 1 more</code></p>
<p><code>*/</code></p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>
<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>
<p>下面是IOException类的完整源代码，可以借鉴。<br>|123456789101112131415161718192021222324|<code>public</code> <code>class</code> <code>IOException ``extends</code> <code>Exception``&#123;``    ``static</code> <code>final</code> <code>long</code> <code>serialVersionUID = 7818375828146090155L;</code> <code>    ``public</code> <code>IOException()``    ``&#123;``        ``super``();``    ``&#125;</code> <code>    ``public</code> <code>IOException(String message)``    ``&#123;``        ``super``(message);``    ``&#125;</code> <code>    ``public</code> <code>IOException(String message, Throwable cause)``    ``&#123;``        ``super``(message, cause);``    ``&#125;</code> <code>    ``public</code> <code>IOException(Throwable cause)``    ``&#123;``        ``super``(cause);``    ``&#125;``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p><code>&#123;</code></p>
<p> </p>
<p><code>    ``&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>    ``public</code> <code>IOException(String message)</code></p>
<p><code>        ``super``(message);</code></p>
<p> </p>
<p><code>    ``&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>    ``public</code> <code>IOException(Throwable cause)</code></p>
<p><code>        ``super``(cause);</code></p>
<p><code>&#125;</code></p>
<h2 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h2><p>1、当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。</p>
<p>例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。</p>
<p>至于为什么？我想，也许下面的例子可以说明。<br>|1234567891011121314151617181920212223242526272829303132333435363738|<code>class</code> <code>Father``&#123;``    ``public</code> <code>void</code> <code>start() ``throws</code> <code>IOException``    ``&#123;``        ``throw</code> <code>new</code> <code>IOException();``    ``&#125;``&#125;</code> <code>class</code> <code>Son ``extends</code> <code>Father``&#123;``    ``public</code> <code>void</code> <code>start() ``throws</code> <code>Exception``    ``&#123;``        ``throw</code> <code>new</code> <code>SQLException();``    ``&#125;``&#125;``/**********************假设上面的代码是允许的（实质是错误的）***********************/``class</code> <code>Test``&#123;``    ``public</code> <code>static</code> <code>void</code> <code>main(String[] args)``    ``&#123;``        ``Father[] objs = ``new</code> <code>Father[``2``];``        ``objs[``0``] = ``new</code> <code>Father();``        ``objs[``1``] = ``new</code> <code>Son();</code> <code>        ``for``(Father obj:objs)``        ``&#123;``        ``//因为Son类抛出的实质是SQLException，而IOException无法处理它。``        ``//那么这里的try。。catch就不能处理Son中的异常。``        ``//多态就不能实现了。``            ``try</code> <code>&#123;``                 ``obj.start();``            ``&#125;``catch``(IOException)``            ``&#123;``                 ``//处理IOException``            ``&#125;``         ``&#125;``   ``&#125;``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p>34</p>
<p>36</p>
<p>38</p>
<p><code>&#123;</code></p>
<p><code>    ``&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p> </p>
<p><code>&#123;</code></p>
<p><code>    ``&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>/**********************假设上面的代码是允许的（实质是错误的）***********************/</code></p>
<p><code>&#123;</code></p>
<p><code>    ``&#123;</code></p>
<p><code>        ``objs[``0``] = ``new</code> <code>Father();</code></p>
<p> </p>
<p><code>        ``&#123;</code></p>
<p><code>        ``//那么这里的try。。catch就不能处理Son中的异常。</code></p>
<p><code>            ``try</code> <code>&#123;</code></p>
<p><code>            ``&#125;``catch``(IOException)</code></p>
<p><code>                 ``//处理IOException</code></p>
<p><code>         ``&#125;</code></p>
<p><code>&#125;</code></p>
<p>2、Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>
<p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p>
<h2 id="finally块和return"><a href="#finally块和return" class="headerlink" title="finally块和return"></a>finally块和return</h2><p>首先一个不容易理解的事实：在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。<br>|12345678910111213141516|<code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)``&#123;``    ``int</code> <code>re = bar();``    ``System.out.println(re);``&#125;``private</code> <code>static</code> <code>int</code> <code>bar() ``&#123;``    ``try``&#123;``        ``return</code> <code>5``;``    ``&#125; ``finally``&#123;``        ``System.out.println(``&quot;finally&quot;``);``    ``&#125;``&#125;``/*输出：``finally``*/</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p><code>&#123;</code></p>
<p><code>    ``System.out.println(re);</code></p>
<p><code>private</code> <code>static</code> <code>int</code> <code>bar() </code></p>
<p><code>    ``try``&#123;</code></p>
<p><code>    ``&#125; ``finally``&#123;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>/*输出：</code></p>
<p><code>*/</code></p>
<p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p>
<p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p>
<p>finally中的return 会覆盖 try 或者catch中的返回值。<br>|123456789101112131415161718192021222324252627282930313233|<code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)``    ``&#123;``        ``int</code> <code>result;</code> <code>        ``result  =  foo();``        ``System.out.println(result);     ``/////////2</code> <code>        ``result = bar();``        ``System.out.println(result);    ``/////////2``    ``&#125;</code> <code>    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>foo()``    ``&#123;``        ``trz&#123;``            ``int</code> <code>a = ``5</code> <code>/ ``0``;``        ``&#125; ``catch</code> <code>(Exception e)&#123;``            ``return</code> <code>1``;``        ``&#125; ``finally``&#123;``            ``return</code> <code>2``;``        ``&#125;</code> <code>    ``&#125;</code> <code>    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>bar()``    ``&#123;``        ``try</code> <code>&#123;``            ``return</code> <code>1``;``        ``&#125;``finally</code> <code>&#123;``            ``return</code> <code>2``;``        ``&#125;``    ``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args)</code></p>
<p><code>        ``int</code> <code>result;</code></p>
<p><code>        ``result  =  foo();</code></p>
<p> </p>
<p><code>        ``System.out.println(result);    ``/////////2</code></p>
<p> </p>
<p><code>    ``public</code> <code>static</code> <code>int</code> <code>foo()</code></p>
<p><code>        ``trz&#123;</code></p>
<p><code>        ``&#125; ``catch</code> <code>(Exception e)&#123;</code></p>
<p><code>        ``&#125; ``finally``&#123;</code></p>
<p><code>        ``&#125;</code></p>
<p><code>    ``&#125;</code></p>
<p><code>    ``@SuppressWarnings``(``&quot;finally&quot;``)</code></p>
<p><code>    ``&#123;</code></p>
<p><code>            ``return</code> <code>1``;</code></p>
<p><code>            ``return</code> <code>2``;</code></p>
<p><code>    ``&#125;</code></p>
<p>finally中的return会抑制（消灭）前面try或者catch块中的异常<br>|12345678910111213141516171819202122232425262728293031323334353637383940414243444546|<code>class</code> <code>TestException``&#123;``    ``public</code> <code>static</code> <code>void</code> <code>main(String[] args)``    ``&#123;``        ``int</code> <code>result;``        ``try``&#123;``            ``result = foo();``            ``System.out.println(result);           ``//输出100``        ``&#125; ``catch</code> <code>(Exception e)&#123;``            ``System.out.println(e.getMessage());    ``//没有捕获到异常``        ``&#125;</code> <code>        ``try``&#123;``            ``result  = bar();``            ``System.out.println(result);           ``//输出100``        ``&#125; ``catch</code> <code>(Exception e)&#123;``            ``System.out.println(e.getMessage());    ``//没有捕获到异常``        ``&#125;``    ``&#125;</code> <code>    ``//catch中的异常被抑制``    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>foo() ``throws</code> <code>Exception``    ``&#123;``        ``try</code> <code>&#123;``            ``int</code> <code>a = ``5``/``0``;``            ``return</code> <code>1``;``        ``&#125;``catch``(ArithmeticException amExp) &#123;``            ``throw</code> <code>new</code> <code>Exception(``&quot;我将被忽略，因为下面的finally中使用了return&quot;``);``        ``&#125;``finally</code> <code>&#123;``            ``return</code> <code>100``;``        ``&#125;``    ``&#125;</code> <code>    ``//try中的异常被抑制``    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>bar() ``throws</code> <code>Exception``    ``&#123;``        ``try</code> <code>&#123;``            ``int</code> <code>a = ``5``/``0``;``            ``return</code> <code>1``;``        ``&#125;``finally</code> <code>&#123;``            ``return</code> <code>100``;``        ``&#125;``    ``&#125;``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p>34</p>
<p>36</p>
<p>38</p>
<p>40</p>
<p>42</p>
<p>44</p>
<p>46</p>
<p><code>&#123;</code></p>
<p><code>    ``&#123;</code></p>
<p><code>        ``try``&#123;</code></p>
<p><code>            ``System.out.println(result);           ``//输出100</code></p>
<p><code>            ``System.out.println(e.getMessage());    ``//没有捕获到异常</code></p>
<p> </p>
<p><code>            ``result  = bar();</code></p>
<p><code>        ``&#125; ``catch</code> <code>(Exception e)&#123;</code></p>
<p><code>        ``&#125;</code></p>
<p> </p>
<p><code>    ``@SuppressWarnings``(``&quot;finally&quot;``)</code></p>
<p><code>    ``&#123;</code></p>
<p><code>            ``int</code> <code>a = ``5``/``0``;</code></p>
<p><code>        ``&#125;``catch``(ArithmeticException amExp) &#123;</code></p>
<p><code>        ``&#125;``finally</code> <code>&#123;</code></p>
<p><code>        ``&#125;</code></p>
<p> </p>
<p><code>    ``@SuppressWarnings``(``&quot;finally&quot;``)</code></p>
<p><code>    ``&#123;</code></p>
<p><code>            ``int</code> <code>a = ``5``/``0``;</code></p>
<p><code>        ``&#125;``finally</code> <code>&#123;</code></p>
<p><code>        ``&#125;</code></p>
<p><code>&#125;</code></p>
<p>finally中的异常会覆盖（消灭）前面try或者catch中的异常<br>|123456789101112131415161718192021222324252627282930313233343536373839404142434445|<code>class</code> <code>TestException``&#123;``    ``public</code> <code>static</code> <code>void</code> <code>main(String[] args)``    ``&#123;``        ``int</code> <code>result;``        ``try``&#123;``            ``result = foo();``        ``&#125; ``catch</code> <code>(Exception e)&#123;``            ``System.out.println(e.getMessage());    ``//输出：我是finaly中的Exception``        ``&#125;</code> <code>        ``try``&#123;``            ``result  = bar();``        ``&#125; ``catch</code> <code>(Exception e)&#123;``            ``System.out.println(e.getMessage());    ``//输出：我是finaly中的Exception``        ``&#125;``    ``&#125;</code> <code>    ``//catch中的异常被抑制``    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>foo() ``throws</code> <code>Exception``    ``&#123;``        ``try</code> <code>&#123;``            ``int</code> <code>a = ``5``/``0``;``            ``return</code> <code>1``;``        ``&#125;``catch``(ArithmeticException amExp) &#123;``            ``throw</code> <code>new</code> <code>Exception(``&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;``);``        ``&#125;``finally</code> <code>&#123;``            ``throw</code> <code>new</code> <code>Exception(``&quot;我是finaly中的Exception&quot;``);``        ``&#125;``    ``&#125;</code> <code>    ``//try中的异常被抑制``    ``@SuppressWarnings``(``&quot;finally&quot;``)``    ``public</code> <code>static</code> <code>int</code> <code>bar() ``throws</code> <code>Exception``    ``&#123;``        ``try</code> <code>&#123;``            ``int</code> <code>a = ``5``/``0``;``            ``return</code> <code>1``;``        ``&#125;``finally</code> <code>&#123;``            ``throw</code> <code>new</code> <code>Exception(``&quot;我是finaly中的Exception&quot;``);``        ``&#125;</code> <code>    ``&#125;``&#125;</code></p>
<p>2</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>14</p>
<p>16</p>
<p>18</p>
<p>20</p>
<p>22</p>
<p>24</p>
<p>26</p>
<p>28</p>
<p>30</p>
<p>32</p>
<p>34</p>
<p>36</p>
<p>38</p>
<p>40</p>
<p>42</p>
<p>44</p>
<p><code>class</code> <code>TestException</code></p>
<p><code>    ``public</code> <code>static</code> <code>void</code> <code>main(String[] args)</code></p>
<p><code>        ``int</code> <code>result;</code></p>
<p><code>            ``result = foo();</code></p>
<p><code>            ``System.out.println(e.getMessage());    ``//输出：我是finaly中的Exception</code></p>
<p> </p>
<p><code>            ``result  = bar();</code></p>
<p><code>            ``System.out.println(e.getMessage());    ``//输出：我是finaly中的Exception</code></p>
<p><code>    ``&#125;</code></p>
<p><code>    ``//catch中的异常被抑制</code></p>
<p><code>    ``public</code> <code>static</code> <code>int</code> <code>foo() ``throws</code> <code>Exception</code></p>
<p><code>        ``try</code> <code>&#123;</code></p>
<p><code>            ``return</code> <code>1``;</code></p>
<p><code>            ``throw</code> <code>new</code> <code>Exception(``&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;``);</code></p>
<p><code>            ``throw</code> <code>new</code> <code>Exception(``&quot;我是finaly中的Exception&quot;``);</code></p>
<p><code>    ``&#125;</code></p>
<p><code>    ``//try中的异常被抑制</code></p>
<p><code>    ``public</code> <code>static</code> <code>int</code> <code>bar() ``throws</code> <code>Exception</code></p>
<p><code>        ``try</code> <code>&#123;</code></p>
<p><code>            ``return</code> <code>1``;</code></p>
<p><code>            ``throw</code> <code>new</code> <code>Exception(``&quot;我是finaly中的Exception&quot;``);</code></p>
<p> </p>
<p><code>&#125;</code></p>
<p>上面的3个例子都异于常人的编码思维，因此我建议：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-IdeaVim-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E8%BD%AC%E8%BD%BD-IdeaVim-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转载：IdeaVim-常用操作"><a href="#转载：IdeaVim-常用操作" class="headerlink" title="转载：IdeaVim-常用操作"></a>转载：IdeaVim-常用操作</h1><p>作者:<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhaozihan/">六月的余晖</a> <br/><br>出处:<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhaozihan/">http://www.cnblogs.com/zhaozihan/</a> <br/><br>有删减，大部分摘自以上文章，亲测有效</p>
<h1 id="IdeaVim简介"><a href="#IdeaVim简介" class="headerlink" title="IdeaVim简介"></a>IdeaVim简介</h1><p>IdeaVim是IntelliJ IDEA的一款插件，他提高了我们写代码的速度，对代码的跳转，查找也很友好。</p>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>i模式即为编辑模式，按下字母i开启就可以打字。</p>
<p>从i模式切换为Vim，按下键盘的Esc键切回Vim。</p>
<p>上：k , 下：j , 左： h , 右：l</p>
<p>例如：“hello world,I’m wrting”,当光标在h时，连按w光标依次显示为：w &gt; , &gt; I &gt; ’ &gt; m &gt; w &gt; “</p>
<p>例如：“hello world,I’m wrting”,当光标在h时，连按大写的W光标依次显示为：w &gt; I &gt; w</p>
<p>情况与w类似。</p>
<p>例如：“hello world,I’m wrting”,当光标在h时，输入fw，光标跳转到字符world的w字符处。</p>
<p>例如：“hello world,I’m wrting”,当光标在d时，输入Fw，光标跳转到字符world的w字符处。</p>
<p>例如：“hello world,I’m wrting”,当光标在h时，输入td，光标跳转到字符world的l字符处。</p>
<p>例如：“hello world,I’m wrting”,当光标在d时，输入Tw，光标跳转到字符world的o字符处。</p>
<p>粘贴至光标的下一行，例如：“hello world,I’m wrting”,当光标在此行时，输入yyp，当前行复制并粘贴，下面又多出一行。</p>
<p>粘贴10次</p>
<p>例如：当光标在第一行hello的h字符处，输入vjj <br/><br><img alt="这里写图片描述" src="https://images2015.cnblogs.com/blog/917807/201701/917807-20170118171916234-1112423646.png" title=""/></p>
<p>删除当前行在内以下的5行。</p>
<p>从光标所在位置处逐个正向删除</p>
<p>例如：“hello world,I’m wrting”,当光标在h时，输入dfw，结果为“orld,I’m wrting”。</p>
<p>在ideaVim中取消Vim模式可以使用tools-&gt;Vim Emulator</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[%E8%BD%AC%E8%BD%BD]%E5%B0%8F%E7%99%BD%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%EF%BC%8C%E8%BF%9E%E7%BB%AD%E5%88%B7%E9%A2%98%E4%B8%89%E5%B9%B4%EF%BC%8C%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E8%BD%AC%E8%BD%BD-%5B%E8%BD%AC%E8%BD%BD%5D%E5%B0%8F%E7%99%BD%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%EF%BC%8C%E8%BF%9E%E7%BB%AD%E5%88%B7%E9%A2%98%E4%B8%89%E5%B9%B4%EF%BC%8C%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转载：-转载-小白一路走来，连续刷题三年，谈谈我的算法学习经验"><a href="#转载：-转载-小白一路走来，连续刷题三年，谈谈我的算法学习经验" class="headerlink" title="转载：[转载]小白一路走来，连续刷题三年，谈谈我的算法学习经验"></a>转载：[转载]小白一路走来，连续刷题三年，谈谈我的算法学习经验</h1><p>转载自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kubidemanong/p/10996134.html">小白一路走来，连续刷题三年，谈谈我的算法学习经验</a><br/><br>说得很中肯，值得推荐</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[Java%E9%9B%86%E5%90%88]%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E8%BD%AC%E8%BD%BD-%5BJava%E9%9B%86%E5%90%88%5D%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="转载：-Java集合-彻底搞懂HashMap-HashTable-ConcurrentHashMap之关联（各大公司面试经常遇到）"><a href="#转载：-Java集合-彻底搞懂HashMap-HashTable-ConcurrentHashMap之关联（各大公司面试经常遇到）" class="headerlink" title="转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）"></a>转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）</h1><p>注: 今天看到的一篇讲hashMap,hashTable,concurrentHashMap很透彻的一篇文章, 感谢原作者的分享. <br/><br>原文地址: <a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangerqing/article/details/8193118">http://blog.csdn.net/zhangerqing/article/details/8193118</a> <br/><br><br/><br>Java集合类是个非常重要的知识点，HashMap、HashTable、ConcurrentHashMap等算是集合类中的重点，可谓“重中之重”，首先来看个问题，如面试官问你：HashMap和HashTable有什么区别，一个比较简单的回答是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。</p>
<p>能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？能把第二个问题完整的答出来，说明你的基础算是不错的了。带着这个问题，本章开始系<strong>Java之美[从菜鸟到高手演变]系列</strong>之深入解析HashMap和HashTable类应用而生！总想在文章的开头说点儿什么，但又无从说起。从最近的一些面试说起吧，感受就是：知识是永无止境的，永远不要觉得自己已经掌握了某些东西。如果对哪一块知识感兴趣，那么，请多多的花时间，哪怕最基础的东西也要理解它的原理，尽量往深了研究，在学习的同时，记得多与大家交流沟通，因为也许某些东西，从你自己的角度，是很难发现的，因为你并没有那么多的实验环境去发现他们。只有交流的多了，才能及时找出自己的不足，才能认识到：“哦，原来我还有这么多不知道的东西！”。</p>
<p><strong>一、HashMap的内部存储结构</strong> <br/><br>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表，数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。而链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。有没有一种数据结构来综合一下数组和链表，以便发挥他们各自的优势？答案是肯定的！就是：哈希表。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”，如下图：</p>
<img alt="" src="https://img-my.csdn.net/uploads/201211/17/1353118778_2052.png"/>


<p>从上图中，我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16&#x3D;12,28%16&#x3D;12,108%16&#x3D;12,140%16&#x3D;12。所以12、28、108以及140都存储在数组下标为12的位置。它的内部其实是用一个Entity数组来实现的，属性有key、value、next。接下来我会从初始化阶段详细的讲解HashMap的内部结构。</p>
<p><strong><em>1、初始化 <br/><br></em></strong>首先来看三个常量： <br/><br>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16; 初始容量：16 <br/><br>static final int MAXIMUM_CAPACITY &#x3D; 1  <br/><br>&lt;&lt; 30; 最大容量：2的30次方：1073741824 <br/><br>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;  <br/><br>装载因子，后面再说它的作用 <br/><br>来看个无参构造方法，也是我们最常用的：</p>
<li>
public HashMap() {  </li><li>
        this.loadFactor = DEFAULT_LOAD_FACTOR;  </li><li>
        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);  </li><li>
        table = new Entry[DEFAULT_INITIAL_CAPACITY];  </li><li>
        init();  </li><li>
    }  </li>

<p>loadFactor、threshold的值在此处没有起到作用，不过他们在后面的扩容方面会用到，此处只需理解table&#x3D;new Entry[DEFAULT_INITIAL_CAPACITY].说明，默认就是开辟16个大小的空间。另外一个重要的构造方法：</p>
<li>
public HashMap(int initialCapacity, float loadFactor) {  </li><li>
        if (initialCapacity &lt; 0)  </li><li>
            throw new IllegalArgumentException("Illegal initial capacity: " +  </li><li>
                                               initialCapacity);  </li><li>
        if (initialCapacity &gt; MAXIMUM_CAPACITY)  </li><li>
            initialCapacity = MAXIMUM_CAPACITY;  </li><li>
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </li><li>
            throw new IllegalArgumentException("Illegal load factor: " +  </li><li>
                                               loadFactor);  </li><li>
  </li><li>
        // Find a power of 2 &gt;= initialCapacity  </li><li>
        int capacity = 1;  </li><li>
        while (capacity &lt; initialCapacity)  </li><li>
            capacity &lt;&lt;= 1;  </li><li>
  </li><li>
        this.loadFactor = loadFactor;  </li><li>
        threshold = (int)(capacity * loadFactor);  </li><li>
        table = new Entry[capacity];  </li><li>
        init();  </li><li>
    }  </li>

<br/>
就是说传入参数的构造方法，我们把重点放在：

<li>
while (capacity &lt; initialCapacity)  </li><li>
           capacity &lt;&lt;= 1;  </li>

<br/>
上面，该代码的意思是，实际的开辟的空间要大于传入的第一个参数的值。举个例子：<br/>
new HashMap(7,0.8),loadFactor为0.8，capacity为7，通过上述代码后，capacity的值为：8.（1 &lt;&lt; 2的结果是4,2 &lt;&lt; 2的结果为8&lt;此处感谢网友wego1234的指正&gt;）。所以，最终capacity的值为8，最后通过new Entry[capacity]来创建大小为capacity的数组，所以，这种方法最红取决于capacity的大小。<br/>
<em><strong>2、put(Object key,Object value)操作<br/>
</strong></em> <br/>
当调用put操作时，首先判断key是否为null，如下代码1处：

<li>
&lt;p&gt;public V put(K key, V value) {  </li><li>
        if (key == null)  </li><li>
            return putForNullKey(value);  </li><li>
        int hash = hash(key.hashCode());  </li><li>
        int i = indexFor(hash, table.length);  </li><li>
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }&lt;/p&gt;&lt;p&gt;        modCount++;  </li><li>
        addEntry(hash, key, value, i);  </li><li>
        return null;  </li><li>
    }&lt;/p&gt;  </li>

<br/>
如果**key是null**，则调用如下代码：

<li>
private V putForNullKey(V value) {  </li><li>
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {  </li><li>
            if (e.key == null) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }  </li><li>
        modCount++;  </li><li>
        addEntry(0, null, value, 0);  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
就是说，获取Entry的第一个元素table[0]，并基于第一个元素的next属性开始遍历，直到找到key为null的Entry，将其value设置为新的value值。<br/>
如果没有找到key为null的元素，则调用如上述代码的addEntry(0, null, value, 0);增加一个新的entry，代码如下：

<li>
void addEntry(int hash, K key, V value, int bucketIndex) {  </li><li>
    Entry&lt;K,V&gt; e = table[bucketIndex];  </li><li>
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </li><li>
        if (size++ &gt;= threshold)  </li><li>
            resize(2 * table.length);  </li><li>
    }  </li>

<br/>
先获取第一个元素table[bucketIndex],传给e对象，新建一个entry，key为null，value为传入的value值，next为获取的e对象。如果容量大于threshold，容量扩大2倍。<br/>
如果**key不为null**，这也是大多数的情况，重新看一下源码：

<li>
public V put(K key, V value) {  </li><li>
        if (key == null)  </li><li>
            return putForNullKey(value);  </li><li>
        int hash = hash(key.hashCode());//---------------2---------------  </li><li>
        int i = indexFor(hash, table.length);  </li><li>
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {//--------------3-----------  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }//-------------------4------------------  </li><li>
        modCount++;//----------------5----------  </li><li>
        addEntry(hash, key, value, i);-------------6-----------  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
看源码中2处，首先会进行key.hashCode()操作，获取key的哈希值，hashCode()是Object类的一个方法，为本地方法，内部实现比较复杂，我们<br/>
会在后面作单独的关于Java中Native方法的分析中介绍。hash()的源码如下：

<li>
static int hash(int h) {  </li><li>
        // This function ensures that hashCodes that differ only by  </li><li>
        // constant multiples at each bit position have a bounded  </li><li>
        // number of collisions (approximately 8 at default load factor).  </li><li>
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </li><li>
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </li><li>
    }  </li>

<p>int i &#x3D; indexFor(hash, table.length);的意思，相当于int i &#x3D; hash % Entry[].length;得到i后，就是在Entry数组中的位置，（<del>上述代码5和6处是如果Entry数组中不存在新要增加的元素，则执行5,6处的代码，如果存在，即Hash冲突，则执行 3-4处的代码，此处HashMap中采用链地址法解决Hash冲突</del>。此处经网友<strong>bbycszh</strong>指正，发现上述陈述有些问题）。重新解释：其实不管Entry数组中i位置有无元素，都会去执行5-6处的代码，如果没有，则直接新增，如果有，则将新元素设置为Entry[0]，其next指针指向原有对象，即原有对象为Entry[1]。具体方法可以解释为下面的这段文字：（<strong>3-4处的代码只是检查在索引为i的这条链上有没有key重复的，有则替换且返回原值，程序不再去执行5-6处的代码，无则无处理</strong>）</p>
<p>上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。如， 第一个键值对A进来，通过计算其key的hash得到的i&#x3D;0，记做:Entry[0] &#x3D; A。一会后又进来一个键值对B，通过计算其i也等于0，现在怎么办？HashMap会这样做:B.next &#x3D; A,Entry[0] &#x3D; B,如果又进来C,i也等于0,那么C.next &#x3D; B,Entry[0] &#x3D; C；这样我们发现i&#x3D;0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,也就是说数组中存储的是最后插入的元素。</p>
<p>到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。<br/></p>
<p><strong><strong>2、get(Object key)操作</strong></strong><br/><br>get(Object key)操作时根据键来获取值，如果了解了put操作，get操作容易理解，先来看看源码的实现：</p>
<li>
public V get(Object key) {  </li><li>
        if (key == null)  </li><li>
            return getForNullKey();  </li><li>
        int hash = hash(key.hashCode());  </li><li>
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </li><li>
             e != null;  </li><li>
             e = e.next) {  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))//-------------------1----------------  </li><li>
                return e.value;  </li><li>
        }  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
意思就是：1、当key为null时，调用getForNullKey()，源码如下：

<li>
private V getForNullKey() {  </li><li>
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {  </li><li>
            if (e.key == null)  </li><li>
                return e.value;  </li><li>
        }  </li><li>
        return null;  </li><li>
    }  </li>

<p>2、当key不为null时，先根据hash函数得到hash值，在更具indexFor()得到i的值，循环遍历链表，如果有：key值等于已存在的key值，则返回其value。如上述get()代码1处判断。</p>
<p>总结下HashMap新增put和获取get操作：</p>
<li>
//存储时:  </li><li>
int hash = key.hashCode();  </li><li>
int i = hash % Entry[].length;  </li><li>
Entry[i] = value;  </li><li>
  </li><li>
//取值时:  </li><li>
int hash = key.hashCode();  </li><li>
int i = hash % Entry[].length;  </li><li>
return Entry[i];  </li>

<p>理解了就比较简单。</p>
<p>此处附一个简单的HashMap小算法应用：</p>
<li>
package com.xtfggef.hashmap;  </li><li>
  </li><li>
import java.util.HashMap;  </li><li>
import java.util.Map;  </li><li>
import java.util.Set;  </li><li>
  </li><li>
/** </li><li>
 * 打印在数组中出现n/2以上的元素 </li><li>
 * 利用一个HashMap来存放数组元素及出现的次数 </li><li>
 * @author erqing </li><li>
 * </li><li>
 */  </li><li>
public class HashMapTest {  </li><li>
      </li><li>
    public static void main(String[] args) {  </li><li>
          </li><li>
        int [] a = {2,3,2,2,1,4,2,2,2,7,9,6,2,2,3,1,0};  </li><li>
          </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();  </li><li>
        for(int i=0; i&lt;a.length; i++){  </li><li>
            if(map.containsKey(a[i])){  </li><li>
                int tmp = map.get(a[i]);  </li><li>
                tmp+=1;  </li><li>
                map.put(a[i], tmp);  </li><li>
            }else{  </li><li>
                map.put(a[i], 1);  </li><li>
            }  </li><li>
        }  </li><li>
        Set&lt;Integer&gt; set = map.keySet();//------------1------------  </li><li>
        for (Integer s : set) {  </li><li>
            if(map.get(s)&gt;=a.length/2){  </li><li>
                System.out.println(s);  </li><li>
            }  </li><li>
        }//--------------2---------------  </li><li>
    }  </li><li>
}  </li>

<p>此处注意两个地方，map.containsKey()，还有就是上述1-2处的代码。</p>
<p>理解了HashMap的上面的操作，其它的大多数方法都很容易理解了。搞清楚它的内部存储机制，一切OK！<br/></p>
<p><strong>二、HashTable的内部存储结构</strong></p>
<p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>
<p>2、HashTable不允许有null值的存在。</p>
<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>
<p><strong>三、HashTable和ConcurrentHashMap的比较</strong></p>
<p>如我开篇所说一样，ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？</p>
<p>之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，<strong>锁住的都是对象整体</strong>，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。关于concurrentLevel稍后介绍。</p>
<p><strong><strong>1、构造方法</strong></strong></p>
<p>为了容易理解，我们先从构造函数说起。ConcurrentHashMap是基于一个叫Segment数组的，其实和Entry类似，如下：</p>
<li>
public ConcurrentHashMap()  </li><li>
  {  </li><li>
    this(16, 0.75F, 16);  </li><li>
  }  </li>

<br/>
默认传入值16，调用下面的方法：

<li>
public ConcurrentHashMap(int paramInt1, float paramFloat, int paramInt2)  </li><li>
  {  </li><li>
    if ((paramFloat &lt;= 0F) || (paramInt1 &lt; 0) || (paramInt2 &lt;= 0))  </li><li>
      throw new IllegalArgumentException();  </li><li>
  </li><li>
    if (paramInt2 &gt; 65536) {  </li><li>
      paramInt2 = 65536;  </li><li>
    }  </li><li>
  </li><li>
    int i = 0;  </li><li>
    int j = 1;  </li><li>
    while (j &lt; paramInt2) {  </li><li>
      ++i;  </li><li>
      j &lt;&lt;= 1;  </li><li>
    }  </li><li>
    this.segmentShift = (32 - i);  </li><li>
    this.segmentMask = (j - 1);  </li><li>
    this.segments = Segment.newArray(j);  </li><li>
  </li><li>
    if (paramInt1 &gt; 1073741824)  </li><li>
      paramInt1 = 1073741824;  </li><li>
    int k = paramInt1 / j;  </li><li>
    if (k * j &lt; paramInt1)  </li><li>
      ++k;  </li><li>
    int l = 1;  </li><li>
    while (l &lt; k)  </li><li>
      l &lt;&lt;= 1;  </li><li>
  </li><li>
    for (int i1 = 0; i1 &lt; this.segments.length; ++i1)  </li><li>
      this.segments[i1] = new Segment(l, paramFloat);  </li><li>
  }  </li>

<br/>
你会发现比HashMap的构造函数多一个参数，paramInt1就是我们之前谈过的initialCapacity，就是数组的初始化大小，paramfloat为loadFactor（装载因子），而paramInt2则是我们所要说的concurrentLevel，这三个值分别被初始化为16,0.75,16，经过：

<li>
while (j &lt; paramInt2) {  </li><li>
      ++i;  </li><li>
      j &lt;&lt;= 1;  </li><li>
    }  </li>

<br/>
后，j就是我们最终要开辟的数组的size值，当paramInt1为16时，计算出来的size值就是16.通过：


<p>this.segments &#x3D; Segment.newArray(j)后，我们看出了，最终稿创建的Segment数组的大小为16.最终创建Segment对象时：</p>
<li>
this.segments[i1] = new Segment(cap, paramFloat);  </li>

<p>需要cap值，而cap值来源于：</p>
<li>
int k = paramInt1 / j;  </li><li>
  if (k * j &lt; paramInt1)  </li><li>
    ++k;  </li><li>
  int cap = 1;  </li><li>
  while (cap &lt; k)  </li><li>
    cap &lt;&lt;= 1;  </li>

<p>组后创建大小为cap的数组。最后根据数组的大小及paramFloat的值算出了threshold的值：</p>
<p>this.threshold &#x3D; (int)(paramArrayOfHashEntry.length * this.loadFactor)。</p>
<p><strong><strong>2、put操作</strong></strong></p>
<li>
public V put(K paramK, V paramV)  </li><li>
  {  </li><li>
    if (paramV == null)  </li><li>
      throw new NullPointerException();  </li><li>
    int i = hash(paramK.hashCode());  </li><li>
    return segmentFor(i).put(paramK, i, paramV, false);  </li><li>
  }  </li>

<br/>
与HashMap不同的是，如果key为null，直接抛出NullPointer异常，之后，同样先计算hashCode的值，再计算hash值，不过此处hash函数和HashMap中的不一样：

<li>
private static int hash(int paramInt)  </li><li>
  {  </li><li>
    paramInt += (paramInt &lt;&lt; 15 ^ 0xFFFFCD7D);  </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 10;  </li><li>
    paramInt += (paramInt &lt;&lt; 3);  </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 6;  </li><li>
    paramInt += (paramInt &lt;&lt; 2) + (paramInt &lt;&lt; 14);  </li><li>
    return (paramInt ^ paramInt &gt;&gt;&gt; 16);  </li><li>
  }  </li>

<br/>
 

<li>
final Segment&lt;K, V&gt; segmentFor(int paramInt)  </li><li>
  {  </li><li>
    return this.segments[(paramInt &gt;&gt;&gt; this.segmentShift &amp; this.segmentMask)];  </li><li>
  }  </li>

<br/>
根据上述代码找到Segment对象后，调用put来操作：

<li>
V put(K paramK, int paramInt, V paramV, boolean paramBoolean)  </li><li>
{  </li><li>
  lock();  </li><li>
  try {  </li><li>
    Object localObject1;  </li><li>
    Object localObject2;  </li><li>
    int i = this.count;  </li><li>
    if (i++ &gt; this.threshold)  </li><li>
      rehash();  </li><li>
    ConcurrentHashMap.HashEntry[] arrayOfHashEntry = this.table;  </li><li>
    int j = paramInt &amp; arrayOfHashEntry.length - 1;  </li><li>
    ConcurrentHashMap.HashEntry localHashEntry1 = arrayOfHashEntry[j];  </li><li>
    ConcurrentHashMap.HashEntry localHashEntry2 = localHashEntry1;  </li><li>
    while ((localHashEntry2 != null) &amp;&amp; (((localHashEntry2.hash != paramInt) || (!(paramK.equals(localHashEntry2.key)))))) {  </li><li>
      localHashEntry2 = localHashEntry2.next;  </li><li>
    }  </li><li>
  </li><li>
    if (localHashEntry2 != null) {  </li><li>
      localObject1 = localHashEntry2.value;  </li><li>
      if (!(paramBoolean))  </li><li>
        localHashEntry2.value = paramV;  </li><li>
    }  </li><li>
    else {  </li><li>
      localObject1 = null;  </li><li>
      this.modCount += 1;  </li><li>
      arrayOfHashEntry[j] = new ConcurrentHashMap.HashEntry(paramK, paramInt, localHashEntry1, paramV);  </li><li>
      this.count = i;  </li><li>
    }  </li><li>
    return localObject1;  </li><li>
  } finally {  </li><li>
    unlock();  </li><li>
  }  </li><li>
}  </li>

<br/>
先调用lock()，lock是ReentrantLock类的一个方法，用当前存储的个数+1来和threshold比较，如果大于threshold，则进行rehash，将当前的容量扩大2倍，重新进行hash。之后对hash的值和数组大小-1进行按位于操作后，得到当前的key需要放入的位置，从这儿开始，和HashMap一样。


<p>从上述的分析看出，<strong><strong>ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</strong></strong></p>
<p>在多线程的环境中，相对于HashTable，ConcurrentHashMap会带来很大的性能提升！</p>
<p><strong><u>欢迎读者批评指正，有任何建议请联系:</u></strong></p>
<p><strong><u>EGG：<a href="mailto:&#120;&#116;&#x66;&#x67;&#x67;&#x65;&#x66;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#120;&#116;&#x66;&#x67;&#x67;&#x65;&#x66;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>      <a target="_blank" rel="noopener" href="http://weibo.com/xtfggef">http://weibo.com/xtfggef</a></u></strong></p>
<p><strong>四、HashMap常见问题分析</strong></p>
<p><strong><strong>1、此处我觉得</strong></strong>网友**<a href="mailto:huxb23@126">huxb23@126</a>**的一篇文章说的很好，<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/"><strong>分析多线程并发写HashMap线程被hang住的原因</strong></a> ，因为是优秀的资源，此处我整理下搬到这儿。</p>
<p>以下内容转自博文：<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/">http:&#x2F;&#x2F;blog.163.com&#x2F;huxb23@126&#x2F;blog&#x2F;static&#x2F;625898182011211318854&#x2F;</a> </p>
<p>先看原问题代码：</p>
<li>
import java.util.HashMap;  </li><li>
  </li><li>
public class TestLock {  </li><li>
  </li><li>
    private HashMap map = new HashMap();  </li><li>
  </li><li>
    public TestLock() {  </li><li>
        Thread t1 = new Thread() {  </li><li>
            public void run() {  </li><li>
                for (int i = 0; i &lt; 50000; i++) {  </li><li>
                    map.put(new Integer(i), i);  </li><li>
                }  </li><li>
                System.out.println("t1 over");  </li><li>
            }  </li><li>
        };  </li><li>
  </li><li>
        Thread t2 = new Thread() {  </li><li>
            public void run() {  </li><li>
                for (int i = 0; i &lt; 50000; i++) {  </li><li>
                    map.put(new Integer(i), i);  </li><li>
                }  </li><li>
  </li><li>
                System.out.println("t2 over");  </li><li>
            }  </li><li>
        };  </li><li>
  </li><li>
        t1.start();  </li><li>
        t2.start();  </li><li>
  </li><li>
    }  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
        new TestLock();  </li><li>
    }  </li><li>
}  </li>

<br/>
就是启了两个线程，不断的往一个非线程安全的HashMap中put内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会两个线程都被hang住。说到这里，你如果觉得不好好学习ConcurrentHashMap而在这瞎折腾就手下留情跳过吧。<br/>
好吧，分析下HashMap的put函数源码看看问题出在哪，这里就罗列出相关代码（jdk1.6）：

<li>
public V put(K paramK, V paramV)  </li><li>
{  </li><li>
  if (paramK == null)  </li><li>
    return putForNullKey(paramV);  </li><li>
  int i = hash(paramK.hashCode());  </li><li>
  int j = indexFor(i, this.table.length);  </li><li>
  for (Entry localEntry = this.table[j]; localEntry != null; localEntry = localEntry.next)  </li><li>
  {  </li><li>
    if (localEntry.hash == i) { java.lang.Object localObject1;  </li><li>
      if (((localObject1 = localEntry.key) == paramK) || (paramK.equals(localObject1))) {  </li><li>
        java.lang.Object localObject2 = localEntry.value;  </li><li>
        localEntry.value = paramV;  </li><li>
        localEntry.recordAccess(this);  </li><li>
        return localObject2;  </li><li>
      }  </li><li>
    }  </li><li>
  }  </li><li>
  this.modCount += 1;  </li><li>
  addEntry(i, paramK, paramV, j);  </li><li>
  return null;  </li><li>
}  </li><li>
  </li><li>
private V putForNullKey(V paramV)  </li><li>
{  </li><li>
  for (Entry localEntry = this.table[0]; localEntry != null; localEntry = localEntry.next)  </li><li>
    if (localEntry.key == null) {  </li><li>
      java.lang.Object localObject = localEntry.value;  </li><li>
      localEntry.value = paramV;  </li><li>
      localEntry.recordAccess(this);  </li><li>
      return localObject;  </li><li>
    }  </li><li>
  </li><li>
  this.modCount += 1;  </li><li>
  addEntry(0, null, paramV, 0);  </li><li>
  return null;  </li><li>
}  </li>

<p> </p>
<p>通过jconsole（或者thread dump），可以看到线程停在了transfer方法的while循环处。这个transfer方法的作用是，当Map中元素数超过阈值需要resize时，它负责把原Map中的元素映射到新Map中。我修改了HashMap，加上了@标记2和@标记3的代码片断，以打印出死循环时的状态，结果死循环线程总是出现类似这样的输出：“Thread-1,e&#x3D;&#x3D;next:false,e&#x3D;&#x3D;next.next:true,e:108928&#x3D;108928,next:108928&#x3D;108928,eq:true”。<br/><br>这个输出表明：<br/><br>1）这个Entry链中的两个Entry之间的关系是：e&#x3D;e.next.next，造成死循环。<br/><br>2）e.equals(e.next)，但e!&#x3D;e.next。因为测试例子中两个线程put的内容一样，并发时可能同一个key被保存了多个value，这种错误是在addEntry函数产生的，但这和线程死循环没有关系。</p>
<p>接下来就分析transfer中那个while循环了。先所说这个循环正常的功能：src[j]保存的是映射成同一个hash值的多个Entry的链表，这个src[j]可能为null，可能只有一个Entry，也可能由多个Entry链接起来。假设是多个Entry，原来的链是(src[j]&#x3D;a)-&gt;b（也就是src[j]&#x3D;a,a.next&#x3D;b,b.next&#x3D;null），经过while处理后得到了(newTable[i]&#x3D;b)-&gt;a。也就是说，把链表的next关系反向了。</p>
<p>再看看这个while中可能在多线程情况下引起问题的语句。针对两个线程t1和t2,这里它们可能的产生问题的执行序列做些个人分析：</p>
<p>1）假设同一个Entry列表[e-&gt;f-&gt;…]，t1先到，t2后到并都走到while中。t1执行“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”这使得e.next&#x3D;null（初始的newTable[i]为null），newTable[i]指向了e。这时t2执行了“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”，这使得e.next&#x3D;e，e死循环了。因为循环开始处的“final<br> Entry next &#x3D; e.next;”，尽管e自己死循环了，在最后的“e &#x3D; next;”后，两个线程都会跳过e继续执行下去。</p>
<p>2）在while中逐个遍历Entry链表中的Entry而把next关系反向时，newTable[i]成为了被交换的引用，可疑的语句在于“e.next &#x3D; newTable[i];”。假设链表e-&gt;f-&gt;g被t1处理成e&lt;-f&lt;-g，newTable[i]指向了g，这时t2进来了，它一执行“e.next &#x3D; newTable[i];”就使得e-&gt;g，造成了死循环。所以，理论上来说，死循环的Entry个数可能很多。尽管产生了死循环，但是t1执行到了死循环的右边，所以是会继续执行下去的，而t2如果执行“final<br> Entry next &#x3D; e.next;”的next为null，则也会继续执行下去，否则就进入了死循环。</p>
<p>3）似乎情况会更复杂，因为即便线程跳出了死循环，它下一次做resize进入transfer时，有可能因为之前的死循环Entry链表而被hang住（似乎是一定会被hang住）。也有可能，在put检查Entry链表时（@标记1），因为Entry链表的死循环而被hang住。也似乎有可能，活着的线程和死循环的线程同时执行在while里后，两个线程都能活着出去。所以，可能两个线程平安退出，可能一个线程hang在transfer中，可能两个线程都被hang住而又不一定在一个地方。</p>
<p>4）我反复的测试，出现一个线程被hang住的情况最多，都是e&#x3D;e.next.next造成的，这主要就是例子put两份增量数据造成的。我如果去掉@标记3的输出，有时也能复现两个线程都被hang住的情况，但加上后就很难复现出来。我又把put的数据改了下，比如让两个线程put范围不同的数据，就能复现出e&#x3D;e.next，两个线程都被hang住的情况。</p>
<p>上面罗哩罗嗦了很多，一开始我简单的分析后觉得似乎明白了怎么回事，可现在仔细琢磨后似乎又不明白了许多。有一个细节是，每次死循环的key的大小也是有据可循的，我就不打哈了。感觉，如果样本多些，可能出现问题的原因点会很多，也会更复杂，我姑且不再蛋疼下去。至于有人提到ConcurrentHashMap也有这个问题，我觉得不大可能，因为它的put操作是加锁的，如果有这个问题就不叫线程安全的Map了。</p>
<p><strong><strong>2、HashMap中Value可以相同，但是键不可以相同</strong></strong></p>
<p>当插入HashMap的key相同时，会覆盖原有的Value，且返回原Value值，看下面的程序：</p>
<li>
public class Test {  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
          </li><li>
        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();  </li><li>
  </li><li>
        //出入两个Value相同的值，没有问题  </li><li>
        map.put("egg", 1);  </li><li>
        map.put("niu", 1);  </li><li>
          </li><li>
        //插入key相同的值，看返回结果  </li><li>
        int egg = (Integer) map.put("egg", 3);  </li><li>
          </li><li>
        System.out.println(egg);   //输出1  </li><li>
        System.out.println(map.get("egg"));   //输出3，将原值1覆盖  </li><li>
        System.out.println(map.get("niu"));   //输出1  </li><li>
    }  </li><li>
}  </li>

<p>相同的键会被覆盖，且返回原值。</p>
<p><strong><strong>3、HashMap按值排序</strong></strong></p>
<p>给定一个数组，求出每个数据出现的次数并按照次数的由大到小排列出来。我们选用HashMap来做，key存储数组元素，值存储出现的次数，最后用Collections的sort方法对HashMap的值进行排序。代码如下：</p>
<li>
public class Test {  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
  </li><li>
        int data[] = { 2, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2,  </li><li>
                7, 8, 8, 7, 8, 7, 9, 0 };  </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();  </li><li>
        for (int i : data) {  </li><li>
            if (map.containsKey(i)) {//判断HashMap里是否存在  </li><li>
                map.put(i, map.get(i) + 1);//已存在，值+1  </li><li>
            } else {  </li><li>
                map.put(i, 1);//不存在，新增  </li><li>
            }  </li><li>
        }  </li><li>
        //map按值排序  </li><li>
        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(  </li><li>
                map.entrySet());  </li><li>
        Collections.sort(list, new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {  </li><li>
            public int compare(Map.Entry&lt;Integer, Integer&gt; o1,  </li><li>
                    Map.Entry&lt;Integer, Integer&gt; o2) {  </li><li>
                return (o2.getValue() - o1.getValue());  </li><li>
            }  </li><li>
        });  </li><li>
        for (Map.Entry&lt;Integer, Integer&gt; m : list) {  </li><li>
            System.out.println(m.getKey() + "-" + m.getValue());  </li><li>
        }  </li><li>
    }  </li><li>
  </li><li>
}  </li>

<p>输出：</p>
<p>2-6<br/><br>5-5<br/><br>3-4<br/><br>8-3<br/><br>7-3<br/><br>9-1<br/><br>0-1</p>
<li>
public HashMap()
 { </li><li>
        this.loadFactor
 = DEFAULT_LOAD_FACTOR; </li><li>
        threshold = (int)(DEFAULT_INITIAL_CAPACITY
 * DEFAULT_LOAD_FACTOR); </li><li>
        table = new Entry[DEFAULT_INITIAL_CAPACITY]; </li><li>
        init(); </li><li>
    } </li>

<p>loadFactor、threshold的值在此处没有起到作用，不过他们在后面的扩容方面会用到，此处只需理解table&#x3D;new Entry[DEFAULT_INITIAL_CAPACITY].说明，默认就是开辟16个大小的空间。另外一个重要的构造方法：</p>
<li>
public HashMap(int initialCapacity, float loadFactor)
 { </li><li>
        if (initialCapacity
 &lt; 0) </li><li>
            throw new IllegalArgumentException("Illegal
 initial capacity: " + </li><li>
                                               initialCapacity); </li><li>
        if (initialCapacity
 &gt; MAXIMUM_CAPACITY) </li><li>
            initialCapacity = MAXIMUM_CAPACITY; </li><li>
        if (loadFactor
 &lt;= 0 || Float.isNaN(loadFactor)) </li><li>
            throw new IllegalArgumentException("Illegal
 load factor: " + </li><li>
                                               loadFactor); </li><li>
 </li><li>
        // Find a power of 2 &gt;= initialCapacity </li><li>
        int capacity
 = 1; </li><li>
        while (capacity
 &lt; initialCapacity) </li><li>
            capacity &lt;&lt;= 1; </li><li>
 </li><li>
        this.loadFactor
 = loadFactor; </li><li>
        threshold = (int)(capacity
 * loadFactor); </li><li>
        table = new Entry[capacity]; </li><li>
        init(); </li><li>
    } </li>

<br/>
就是说传入参数的构造方法，我们把重点放在：

<li>
while (capacity
 &lt; initialCapacity) </li><li>
           capacity &lt;&lt;= 1; </li>

<br/>
上面，该代码的意思是，实际的开辟的空间要大于传入的第一个参数的值。举个例子： <br/>
new HashMap(7,0.8),loadFactor为0.8，capacity为7，通过上述代码后，capacity的值为：8.（1 &lt;&lt; 2的结果是4,2 &lt;&lt; 2的结果为8&lt;此处感谢网友wego1234的指正&gt;）。所以，最终capacity的值为8，最后通过new Entry[capacity]来创建大小为capacity的数组，所以，这种方法最红取决于capacity的大小。 <br/>
<em><strong>2、put(Object key,Object value)操作 <br/>
</strong></em>  <br/>
当调用put操作时，首先判断key是否为null，如下代码1处：

<li>
&lt;p&gt;public V
 put(K key, V value) { </li><li>
        if (key
 == null) </li><li>
            return putForNullKey(value); </li><li>
        int hash
 = hash(key.hashCode()); </li><li>
        int i
 = indexFor(hash, table.length); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[i]; e != null;
 e = e.next) { </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        }&lt;/p&gt;&lt;p&gt;        modCount++; </li><li>
        addEntry(hash, key, value, i); </li><li>
        return null; </li><li>
    }&lt;/p&gt; </li>

<br/>
如果**key是null**，则调用如下代码：

<li>
private V
 putForNullKey(V value) { </li><li>
        for (Entry&lt;K,V&gt;
 e = table[0]; e != null;
 e = e.next) { </li><li>
            if (e.key
 == null) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        } </li><li>
        modCount++; </li><li>
        addEntry(0, null,
 value, 0); </li><li>
        return null; </li><li>
    } </li>

<br/>
就是说，获取Entry的第一个元素table[0]，并基于第一个元素的next属性开始遍历，直到找到key为null的Entry，将其value设置为新的value值。 <br/>
如果没有找到key为null的元素，则调用如上述代码的addEntry(0, null, value, 0);增加一个新的entry，代码如下：

<li>
void addEntry(int hash,
 K key, V value, int bucketIndex)
 { </li><li>
    Entry&lt;K,V&gt; e = table[bucketIndex]; </li><li>
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash,
 key, value, e); </li><li>
        if (size++
 &gt;= threshold) </li><li>
            resize(2 *
 table.length); </li><li>
    } </li>

<br/>
先获取第一个元素table[bucketIndex],传给e对象，新建一个entry，key为null，value为传入的value值，next为获取的e对象。如果容量大于threshold，容量扩大2倍。 <br/>
如果**key不为null**，这也是大多数的情况，重新看一下源码：

<li>
public V
 put(K key, V value) { </li><li>
        if (key
 == null) </li><li>
            return putForNullKey(value); </li><li>
        int hash
 = hash(key.hashCode());//---------------2--------------- </li><li>
        int i
 = indexFor(hash, table.length); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[i]; e != null;
 e = e.next) {//--------------3----------- </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        }//-------------------4------------------ </li><li>
        modCount++;//----------------5---------- </li><li>
        addEntry(hash, key, value, i);-------------6----------- </li><li>
        return null; </li><li>
    } </li>

<br/>
看源码中2处，首先会进行key.hashCode()操作，获取key的哈希值，hashCode()是Object类的一个方法，为本地方法，内部实现比较复杂，我们 <br/>
会在后面作单独的关于Java中Native方法的分析中介绍。hash()的源码如下：

<li>
static int hash(int h)
 { </li><li>
        // This function ensures that
 hashCodes that differ only by </li><li>
        // constant multiples at each
 bit position have a bounded </li><li>
        // number of collisions (approximately
 8 at default load factor). </li><li>
        h ^= (h &gt;&gt;&gt; 20)
 ^ (h &gt;&gt;&gt; 12); </li><li>
        return h
 ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); </li><li>
    } </li>

<p>int i &#x3D; indexFor(hash, table.length);的意思，相当于int i &#x3D; hash % Entry[].length;得到i后，就是在Entry数组中的位置，（<del>上述代码5和6处是如果Entry数组中不存在新要增加的元素，则执行5,6处的代码，如果存在，即Hash冲突，则执行 3-4处的代码，此处HashMap中采用链地址法解决Hash冲突</del>。此处经网友<strong>bbycszh</strong>指正，发现上述陈述有些问题）。重新解释：其实不管Entry数组中i位置有无元素，都会去执行5-6处的代码，如果没有，则直接新增，如果有，则将新元素设置为Entry[0]，其next指针指向原有对象，即原有对象为Entry[1]。具体方法可以解释为下面的这段文字：（<strong>3-4处的代码只是检查在索引为i的这条链上有没有key重复的，有则替换且返回原值，程序不再去执行5-6处的代码，无则无处理</strong>）</p>
<p>上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。如， 第一个键值对A进来，通过计算其key的hash得到的i&#x3D;0，记做:Entry[0] &#x3D; A。一会后又进来一个键值对B，通过计算其i也等于0，现在怎么办？HashMap会这样做:B.next &#x3D; A,Entry[0] &#x3D; B,如果又进来C,i也等于0,那么C.next &#x3D; B,Entry[0] &#x3D; C；这样我们发现i&#x3D;0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,也就是说数组中存储的是最后插入的元素。</p>
<p>到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。 <br/></p>
<p><strong><strong>2、get(Object key)操作</strong></strong> <br/><br>get(Object key)操作时根据键来获取值，如果了解了put操作，get操作容易理解，先来看看源码的实现：</p>
<li>
public V
 get(Object key) { </li><li>
        if (key
 == null) </li><li>
            return getForNullKey(); </li><li>
        int hash
 = hash(key.hashCode()); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[indexFor(hash, table.length)]; </li><li>
             e != null; </li><li>
             e = e.next) { </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))//-------------------1---------------- </li><li>
                return e.value; </li><li>
        } </li><li>
        return null; </li><li>
    } </li>

<br/>
意思就是：1、当key为null时，调用getForNullKey()，源码如下：

<li>
private V
 getForNullKey() { </li><li>
        for (Entry&lt;K,V&gt;
 e = table[0]; e != null;
 e = e.next) { </li><li>
            if (e.key
 == null) </li><li>
                return e.value; </li><li>
        } </li><li>
        return null; </li><li>
    } </li>

<p>2、当key不为null时，先根据hash函数得到hash值，在更具indexFor()得到i的值，循环遍历链表，如果有：key值等于已存在的key值，则返回其value。如上述get()代码1处判断。</p>
<p>总结下HashMap新增put和获取get操作：</p>
<li>
//存储时: </li><li>
int hash
 = key.hashCode(); </li><li>
int i
 = hash % Entry[].length; </li><li>
Entry[i] = value; </li><li>
 </li><li>
//取值时: </li><li>
int hash
 = key.hashCode(); </li><li>
int i
 = hash % Entry[].length; </li><li>
return Entry[i]; </li>

<p>理解了就比较简单。</p>
<p>此处附一个简单的HashMap小算法应用：</p>
<li>
package com.xtfggef.hashmap; </li><li>
 </li><li>
import java.util.HashMap; </li><li>
import java.util.Map; </li><li>
import java.util.Set; </li><li>
 </li><li>
/** </li><li>
* 打印在数组中出现n/2以上的元素 </li><li>
* 利用一个HashMap来存放数组元素及出现的次数 </li><li>
* @author erqing </li><li>
* </li><li>
*/ </li><li>
public class HashMapTest
 { </li><li>
     </li><li>
    public static void main(String[]
 args) { </li><li>
         </li><li>
        int []
 a = {2,3,2,2,1,4,2,2,2,7,9,6,2,2,3,1,0}; </li><li>
         </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); </li><li>
        for(int i=0;
 i&lt;a.length; i++){ </li><li>
            if(map.containsKey(a[i])){ </li><li>
                int tmp
 = map.get(a[i]); </li><li>
                tmp+=1; </li><li>
                map.put(a[i], tmp); </li><li>
            }else{ </li><li>
                map.put(a[i], 1); </li><li>
            } </li><li>
        } </li><li>
        Set&lt;Integer&gt; set = map.keySet();//------------1------------ </li><li>
        for (Integer
 s : set) { </li><li>
            if(map.get(s)&gt;=a.length/2){ </li><li>
                System.out.println(s); </li><li>
            } </li><li>
        }//--------------2--------------- </li><li>
    } </li><li>
} </li>

<p>此处注意两个地方，map.containsKey()，还有就是上述1-2处的代码。</p>
<p>理解了HashMap的上面的操作，其它的大多数方法都很容易理解了。搞清楚它的内部存储机制，一切OK！ <br/></p>
<p><strong>二、HashTable的内部存储结构</strong></p>
<p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>
<p>2、HashTable不允许有null值的存在。</p>
<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>
<p><strong>三、HashTable和ConcurrentHashMap的比较</strong></p>
<p>如我开篇所说一样，ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？</p>
<p>之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，<strong>锁住的都是对象整体</strong>，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。关于concurrentLevel稍后介绍。</p>
<p><strong><strong>1、构造方法</strong></strong></p>
<p>为了容易理解，我们先从构造函数说起。ConcurrentHashMap是基于一个叫Segment数组的，其实和Entry类似，如下：</p>
<li>
public ConcurrentHashMap() </li><li>
  { </li><li>
    this(16, 0.75F, 16); </li><li>
  } </li>

<br/>
默认传入值16，调用下面的方法：

<li>
public ConcurrentHashMap(int paramInt1, float paramFloat, int paramInt2) </li><li>
  { </li><li>
    if ((paramFloat
 &lt;= 0F) || (paramInt1 &lt; 0)
 || (paramInt2 &lt;= 0)) </li><li>
      throw new IllegalArgumentException(); </li><li>
 </li><li>
    if (paramInt2
 &gt; 65536) { </li><li>
      paramInt2 = 65536; </li><li>
    } </li><li>
 </li><li>
    int i
 = 0; </li><li>
    int j
 = 1; </li><li>
    while (j
 &lt; paramInt2) { </li><li>
      ++i; </li><li>
      j &lt;&lt;= 1; </li><li>
    } </li><li>
    this.segmentShift
 = (32 - i); </li><li>
    this.segmentMask
 = (j - 1); </li><li>
    this.segments
 = Segment.newArray(j); </li><li>
 </li><li>
    if (paramInt1
 &gt; 1073741824) </li><li>
      paramInt1 = 1073741824; </li><li>
    int k
 = paramInt1 / j; </li><li>
    if (k
 * j &lt; paramInt1) </li><li>
      ++k; </li><li>
    int l
 = 1; </li><li>
    while (l
 &lt; k) </li><li>
      l &lt;&lt;= 1; </li><li>
 </li><li>
    for (int i1
 = 0; i1 &lt; this.segments.length;
 ++i1) </li><li>
      this.segments[i1]
 = new Segment(l, paramFloat); </li><li>
  } </li>

<br/>
你会发现比HashMap的构造函数多一个参数，paramInt1就是我们之前谈过的initialCapacity，就是数组的初始化大小，paramfloat为loadFactor（装载因子），而paramInt2则是我们所要说的concurrentLevel，这三个值分别被初始化为16,0.75,16，经过：

<li>
while (j
 &lt; paramInt2) { </li><li>
      ++i; </li><li>
      j &lt;&lt;= 1; </li><li>
    } </li>

<br/>
后，j就是我们最终要开辟的数组的size值，当paramInt1为16时，计算出来的size值就是16.通过：


<p>this.segments &#x3D; Segment.newArray(j)后，我们看出了，最终稿创建的Segment数组的大小为16.最终创建Segment对象时：</p>
<li>
this.segments[i1]
 = new Segment(cap,
 paramFloat); </li>

<p>需要cap值，而cap值来源于：</p>
<li>
int k
 = paramInt1 / j; </li><li>
  if (k
 * j &lt; paramInt1) </li><li>
    ++k; </li><li>
  int cap
 = 1; </li><li>
  while (cap
 &lt; k) </li><li>
    cap &lt;&lt;= 1; </li>

<p>组后创建大小为cap的数组。最后根据数组的大小及paramFloat的值算出了threshold的值：</p>
<p>this.threshold &#x3D; (int)(paramArrayOfHashEntry.length * this.loadFactor)。</p>
<p><strong><strong>2、put操作</strong></strong></p>
<li>
public V
 put(K paramK, V paramV) </li><li>
  { </li><li>
    if (paramV
 == null) </li><li>
      throw new NullPointerException(); </li><li>
    int i
 = hash(paramK.hashCode()); </li><li>
    return segmentFor(i).put(paramK,
 i, paramV, false); </li><li>
  } </li>

<br/>
与HashMap不同的是，如果key为null，直接抛出NullPointer异常，之后，同样先计算hashCode的值，再计算hash值，不过此处hash函数和HashMap中的不一样：

<li>
private static int hash(int paramInt) </li><li>
  { </li><li>
    paramInt += (paramInt &lt;&lt; 15 ^ 0xFFFFCD7D); </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 10; </li><li>
    paramInt += (paramInt &lt;&lt; 3); </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 6; </li><li>
    paramInt += (paramInt &lt;&lt; 2)
 + (paramInt &lt;&lt; 14); </li><li>
    return (paramInt
 ^ paramInt &gt;&gt;&gt; 16); </li><li>
  } </li>

<br/>
 

<li>
final Segment&lt;K,
 V&gt; segmentFor(int paramInt) </li><li>
  { </li><li>
    return this.segments[(paramInt
 &gt;&gt;&gt; this.segmentShift
 &amp; this.segmentMask)]; </li><li>
  } </li>

<br/>
根据上述代码找到Segment对象后，调用put来操作：

<li>
V put(K paramK, int paramInt,
 V paramV, boolean paramBoolean) </li><li>
{ </li><li>
  lock(); </li><li>
  try { </li><li>
    Object localObject1; </li><li>
    Object localObject2; </li><li>
    int i
 = this.count; </li><li>
    if (i++
 &gt; this.threshold) </li><li>
      rehash(); </li><li>
    ConcurrentHashMap.HashEntry[] arrayOfHashEntry = this.table; </li><li>
    int j
 = paramInt &amp; arrayOfHashEntry.length - 1; </li><li>
    ConcurrentHashMap.HashEntry localHashEntry1 = arrayOfHashEntry[j]; </li><li>
    ConcurrentHashMap.HashEntry localHashEntry2 = localHashEntry1; </li><li>
    while ((localHashEntry2
 != null) &amp;&amp; (((localHashEntry2.hash
 != paramInt) || (!(paramK.equals(localHashEntry2.key)))))) { </li><li>
      localHashEntry2 = localHashEntry2.next; </li><li>
    } </li><li>
 </li><li>
    if (localHashEntry2
 != null) { </li><li>
      localObject1 = localHashEntry2.value; </li><li>
      if (!(paramBoolean)) </li><li>
        localHashEntry2.value = paramV; </li><li>
    } </li><li>
    else { </li><li>
      localObject1 = null; </li><li>
      this.modCount
 += 1; </li><li>
      arrayOfHashEntry[j] = new ConcurrentHashMap.HashEntry(paramK,
 paramInt, localHashEntry1, paramV); </li><li>
      this.count
 = i; </li><li>
    } </li><li>
    return localObject1; </li><li>
  } finally { </li><li>
    unlock(); </li><li>
  } </li><li>
} </li>

<br/>
先调用lock()，lock是ReentrantLock类的一个方法，用当前存储的个数+1来和threshold比较，如果大于threshold，则进行rehash，将当前的容量扩大2倍，重新进行hash。之后对hash的值和数组大小-1进行按位于操作后，得到当前的key需要放入的位置，从这儿开始，和HashMap一样。


<p>从上述的分析看出，<strong><strong>ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</strong></strong></p>
<p>在多线程的环境中，相对于HashTable，ConcurrentHashMap会带来很大的性能提升！</p>
<p><strong>四、HashMap常见问题分析</strong></p>
<p><strong><strong>1、此处我觉得</strong></strong>网友**<a href="mailto:huxb23@126">huxb23@126</a>**的一篇文章说的很好，<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/"><strong>分析多线程并发写HashMap线程被hang住的原因</strong></a> ，因为是优秀的资源，此处我整理下搬到这儿。</p>
<p>以下内容转自博文：<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/">http:&#x2F;&#x2F;blog.163.com&#x2F;huxb23@126&#x2F;blog&#x2F;static&#x2F;625898182011211318854&#x2F;</a> </p>
<p>先看原问题代码：</p>
<li>
import java.util.HashMap; </li><li>
 </li><li>
public class TestLock
 { </li><li>
 </li><li>
    private HashMap
 map = new HashMap(); </li><li>
 </li><li>
    public TestLock()
 { </li><li>
        Thread t1 = new Thread()
 { </li><li>
            public void run()
 { </li><li>
                for (int i
 = 0; i &lt; 50000;
 i++) { </li><li>
                    map.put(new Integer(i),
 i); </li><li>
                } </li><li>
                System.out.println("t1 over"); </li><li>
            } </li><li>
        }; </li><li>
 </li><li>
        Thread t2 = new Thread()
 { </li><li>
            public void run()
 { </li><li>
                for (int i
 = 0; i &lt; 50000;
 i++) { </li><li>
                    map.put(new Integer(i),
 i); </li><li>
                } </li><li>
 </li><li>
                System.out.println("t2 over"); </li><li>
            } </li><li>
        }; </li><li>
 </li><li>
        t1.start(); </li><li>
        t2.start(); </li><li>
 </li><li>
    } </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
        new TestLock(); </li><li>
    } </li><li>
} </li>

<br/>
就是启了两个线程，不断的往一个非线程安全的HashMap中put内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会两个线程都被hang住。说到这里，你如果觉得不好好学习ConcurrentHashMap而在这瞎折腾就手下留情跳过吧。 <br/>
好吧，分析下HashMap的put函数源码看看问题出在哪，这里就罗列出相关代码（jdk1.6）：

<li>
public V
 put(K paramK, V paramV) </li><li>
{ </li><li>
  if (paramK
 == null) </li><li>
    return putForNullKey(paramV); </li><li>
  int i
 = hash(paramK.hashCode()); </li><li>
  int j
 = indexFor(i, this.table.length); </li><li>
  for (Entry
 localEntry = this.table[j];
 localEntry != null;
 localEntry = localEntry.next) </li><li>
  { </li><li>
    if (localEntry.hash
 == i) { java.lang.Object localObject1; </li><li>
      if (((localObject1
 = localEntry.key) == paramK) || (paramK.equals(localObject1))) { </li><li>
        java.lang.Object localObject2 = localEntry.value; </li><li>
        localEntry.value = paramV; </li><li>
        localEntry.recordAccess(this); </li><li>
        return localObject2; </li><li>
      } </li><li>
    } </li><li>
  } </li><li>
  this.modCount
 += 1; </li><li>
  addEntry(i, paramK, paramV, j); </li><li>
  return null; </li><li>
} </li><li>
 </li><li>
private V
 putForNullKey(V paramV) </li><li>
{ </li><li>
  for (Entry
 localEntry = this.table[0];
 localEntry != null;
 localEntry = localEntry.next) </li><li>
    if (localEntry.key
 == null) { </li><li>
      java.lang.Object localObject = localEntry.value; </li><li>
      localEntry.value = paramV; </li><li>
      localEntry.recordAccess(this); </li><li>
      return localObject; </li><li>
    } </li><li>
 </li><li>
  this.modCount
 += 1; </li><li>
  addEntry(0, null,
 paramV, 0); </li><li>
  return null; </li><li>
} </li>

<p> </p>
<p>通过jconsole（或者thread dump），可以看到线程停在了transfer方法的while循环处。这个transfer方法的作用是，当Map中元素数超过阈值需要resize时，它负责把原Map中的元素映射到新Map中。我修改了HashMap，加上了@标记2和@标记3的代码片断，以打印出死循环时的状态，结果死循环线程总是出现类似这样的输出：“Thread-1,e&#x3D;&#x3D;next:false,e&#x3D;&#x3D;next.next:true,e:108928&#x3D;108928,next:108928&#x3D;108928,eq:true”。 <br/><br>这个输出表明： <br/><br>1）这个Entry链中的两个Entry之间的关系是：e&#x3D;e.next.next，造成死循环。 <br/><br>2）e.equals(e.next)，但e!&#x3D;e.next。因为测试例子中两个线程put的内容一样，并发时可能同一个key被保存了多个value，这种错误是在addEntry函数产生的，但这和线程死循环没有关系。</p>
<p>接下来就分析transfer中那个while循环了。先所说这个循环正常的功能：src[j]保存的是映射成同一个hash值的多个Entry的链表，这个src[j]可能为null，可能只有一个Entry，也可能由多个Entry链接起来。假设是多个Entry，原来的链是(src[j]&#x3D;a)-&gt;b（也就是src[j]&#x3D;a,a.next&#x3D;b,b.next&#x3D;null），经过while处理后得到了(newTable[i]&#x3D;b)-&gt;a。也就是说，把链表的next关系反向了。</p>
<p>再看看这个while中可能在多线程情况下引起问题的语句。针对两个线程t1和t2,这里它们可能的产生问题的执行序列做些个人分析：</p>
<p>1）假设同一个Entry列表[e-&gt;f-&gt;…]，t1先到，t2后到并都走到while中。t1执行“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”这使得e.next&#x3D;null（初始的newTable[i]为null），newTable[i]指向了e。这时t2执行了“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”，这使得e.next&#x3D;e，e死循环了。因为循环开始处的“final<br> Entry next &#x3D; e.next;”，尽管e自己死循环了，在最后的“e &#x3D; next;”后，两个线程都会跳过e继续执行下去。</p>
<p>2）在while中逐个遍历Entry链表中的Entry而把next关系反向时，newTable[i]成为了被交换的引用，可疑的语句在于“e.next &#x3D; newTable[i];”。假设链表e-&gt;f-&gt;g被t1处理成e&lt;-f&lt;-g，newTable[i]指向了g，这时t2进来了，它一执行“e.next &#x3D; newTable[i];”就使得e-&gt;g，造成了死循环。所以，理论上来说，死循环的Entry个数可能很多。尽管产生了死循环，但是t1执行到了死循环的右边，所以是会继续执行下去的，而t2如果执行“final<br> Entry next &#x3D; e.next;”的next为null，则也会继续执行下去，否则就进入了死循环。</p>
<p>3）似乎情况会更复杂，因为即便线程跳出了死循环，它下一次做resize进入transfer时，有可能因为之前的死循环Entry链表而被hang住（似乎是一定会被hang住）。也有可能，在put检查Entry链表时（@标记1），因为Entry链表的死循环而被hang住。也似乎有可能，活着的线程和死循环的线程同时执行在while里后，两个线程都能活着出去。所以，可能两个线程平安退出，可能一个线程hang在transfer中，可能两个线程都被hang住而又不一定在一个地方。</p>
<p>4）我反复的测试，出现一个线程被hang住的情况最多，都是e&#x3D;e.next.next造成的，这主要就是例子put两份增量数据造成的。我如果去掉@标记3的输出，有时也能复现两个线程都被hang住的情况，但加上后就很难复现出来。我又把put的数据改了下，比如让两个线程put范围不同的数据，就能复现出e&#x3D;e.next，两个线程都被hang住的情况。</p>
<p>上面罗哩罗嗦了很多，一开始我简单的分析后觉得似乎明白了怎么回事，可现在仔细琢磨后似乎又不明白了许多。有一个细节是，每次死循环的key的大小也是有据可循的，我就不打哈了。感觉，如果样本多些，可能出现问题的原因点会很多，也会更复杂，我姑且不再蛋疼下去。至于有人提到ConcurrentHashMap也有这个问题，我觉得不大可能，因为它的put操作是加锁的，如果有这个问题就不叫线程安全的Map了。</p>
<p><strong><strong>2、HashMap中Value可以相同，但是键不可以相同</strong></strong></p>
<p>当插入HashMap的key相同时，会覆盖原有的Value，且返回原Value值，看下面的程序：</p>
<li>
public class Test
 { </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
         </li><li>
        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); </li><li>
 </li><li>
        //出入两个Value相同的值，没有问题 </li><li>
        map.put("egg", 1); </li><li>
        map.put("niu", 1); </li><li>
         </li><li>
        //插入key相同的值，看返回结果 </li><li>
        int egg
 = (Integer) map.put("egg", 3); </li><li>
         </li><li>
        System.out.println(egg);   //输出1 </li><li>
        System.out.println(map.get("egg"));   //输出3，将原值1覆盖 </li><li>
        System.out.println(map.get("niu"));   //输出1 </li><li>
    } </li><li>
} </li>

<p>相同的键会被覆盖，且返回原值。</p>
<p><strong><strong>3、HashMap按值排序</strong></strong></p>
<p>给定一个数组，求出每个数据出现的次数并按照次数的由大到小排列出来。我们选用HashMap来做，key存储数组元素，值存储出现的次数，最后用Collections的sort方法对HashMap的值进行排序。代码如下：</p>
<li>
public class Test
 { </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
 </li><li>
        int data[]
 = { 2, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, </li><li>
                7, 8, 8, 7, 8, 7, 9, 0 }; </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,
 Integer&gt;(); </li><li>
        for (int i
 : data) { </li><li>
            if (map.containsKey(i))
 {//判断HashMap里是否存在 </li><li>
                map.put(i, map.get(i) + 1);//已存在，值+1 </li><li>
            } else { </li><li>
                map.put(i, 1);//不存在，新增 </li><li>
            } </li><li>
        } </li><li>
        //map按值排序 </li><li>
        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer,
 Integer&gt;&gt;( </li><li>
                map.entrySet()); </li><li>
        Collections.sort(list, new Comparator&lt;Map.Entry&lt;Integer,
 Integer&gt;&gt;() { </li><li>
            public int compare(Map.Entry&lt;Integer,
 Integer&gt; o1, </li><li>
                    Map.Entry&lt;Integer, Integer&gt; o2) { </li><li>
                return (o2.getValue()
 - o1.getValue()); </li><li>
            } </li><li>
        }); </li><li>
        for (Map.Entry&lt;Integer,
 Integer&gt; m : list) { </li><li>
            System.out.println(m.getKey() + "-" +
 m.getValue()); </li><li>
        } </li><li>
    } </li><li>
 </li><li>
} </li>

<p>输出：</p>
<p>2-6 <br/><br>5-5 <br/><br>3-4 <br/><br>8-3 <br/><br>7-3 <br/><br>9-1 <br/><br>0-1</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="正则表达式匹配标点符号"><a href="#正则表达式匹配标点符号" class="headerlink" title="正则表达式匹配标点符号"></a>正则表达式匹配标点符号</h1><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/q77533005/article/details/83642725">https://blog.csdn.net/q77533005/article/details/83642725</a></p>
<p>摘抄：<br/><br>str &#x3D; str.replaceAll(“[\pP‘’“”]”, “”);</p>
<p>Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p>\pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。</p>
<p>其他六个是</p>
<p>L：字母；<br/><br>M：标记符号（一般不会单独出现）；<br/><br>Z：分隔符（比如空格、换行等）；<br/><br>S：符号（比如数学符号、货币符号等）；<br/><br>N：数字（比如阿拉伯数字、罗马数字等）；<br/><br>C：其他字符</p>
<p>上面这七个是属性，七个属性下还有若干个子属性，用于更进一步地进行细分。</p>
<p>Java 中用于 Unicode 的正则表达式数据都是由 Unicode 组织提供的。</p>
<p>Unicode 正则表达式标准（可以找到所有的子属性）<br/><br><a target="_blank" rel="noopener" href="http://www.unicode.org/reports/tr18/">http://www.unicode.org/reports/tr18/</a></p>
<p>各 Unicode 字符属性的定义，可以用一看看某个字符具有什么属性。<br/><br><a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a></p>
<p>这个文本文档一行是一个字符，第一列是 Unicode 编码，第二列是字符名，第三列是 Unicode 属性，<br/><br>以及其他一些字符信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-%E5%9C%A8Eclipse%E4%B8%AD%E9%85%8D%E7%BD%AEJava%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-%E5%9C%A8Eclipse%E4%B8%AD%E9%85%8D%E7%BD%AEJava%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：在Eclipse中配置Java模板代码"><a href="#原创：在Eclipse中配置Java模板代码" class="headerlink" title="原创：在Eclipse中配置Java模板代码"></a>原创：在Eclipse中配置Java模板代码</h1><p>1.例如要在x++处加一个try-finally的代码块</p>
<p> </p>
<p>2.右键preference-&gt;Java-&gt;Editor-&gt;Templates ,选择New </p>
<p> </p>
<p>3.插入变量insert variable,其中line_selection表示选中的语句，cursor表示载入代码块后光标的位置</p>
<p> </p>
<p>4.在选中的x++上右键surround with -&gt;tryf()</p>
<p> </p>
<p> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：与HTTP协作的Web服务器"><a href="#原创：与HTTP协作的Web服务器" class="headerlink" title="原创：与HTTP协作的Web服务器"></a>原创：与HTTP协作的Web服务器</h1><h1 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h1><p>HTTP&#x2F;1.1规范允许一台HTTP服务器搭建多个Web站点。这是因为利用了虚拟主机（Virtual Host,又称虚拟服务器）的功能<br/><br>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。<br/><br>当一台服务器内托管了多个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。<br/><br>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p>
<h1 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h1><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。</p>
<h2 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h2><p>代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。<br/><br>在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via首部字段以标记出经过的主机信息。<br/><br>使用代理服务器的理由有：<br/><br>1）利用<mark>缓存技术</mark>减少带宽的流量<br/><br>2）组织内部对特定网站的访问控制<br/><br>3）以获取访问日志为主要目的<br/><br>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关的工作机制和代理很相似。而网关能使通信线路上的服务器提供非HTTP协议服务。<br/><br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</p>
<h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段通信。隧道的目的是确保客户端能与服务器进行<mark>安全</mark>的通信。<br/><br>隧道本身不会去解析HTTP请求。也就是说，请求保持请求原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<p>总结下三者的作用：<br/><br>代理的作用：减少带宽占用，访问控制，比如公司内网访问外网，科学上网（代理有风险）<br/><br>网关的作用：协议转换，比如Web购物网站上进行信用卡结算，与信用卡结算系统联动<br/><br>隧道的作用：远距离安全通信，比如通过外网访问公司内网</p>
<h1 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h1><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。<br/><br>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求。</p>
<h2 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h2><p>缓存有好处，但是利用不当就会出现缓存是脏数据的情况，这个时候就需要在请求的时候，由缓存服务器向源服务器确认数据是否已更新，若更新了，则需要获取新的数据。</p>
<h2 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h2><p>缓存不仅可以存在于缓存服务器中，也可以存在客户端浏览器中。<br/><br>以Internet Explorer程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）<br/><br>和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%A0%94%E7%A3%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%A0%94%E7%A3%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：研磨设计模式笔记之外观模式"><a href="#原创：研磨设计模式笔记之外观模式" class="headerlink" title="原创：研磨设计模式笔记之外观模式"></a>原创：研磨设计模式笔记之外观模式</h1><h1 id="1-不用模式的解决方案"><a href="#1-不用模式的解决方案" class="headerlink" title="1.不用模式的解决方案"></a>1.不用模式的解决方案</h1><h2 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h2><p>开发一个三层结构（表现层，逻辑层，数据层）代码生成工具<br/><br>（1）先看看描述配置的数据Model</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigModel &#123;</span><br><span class="line">    private boolean needGenPresentation = true;</span><br><span class="line">    private boolean needGenBusiness = true;</span><br><span class="line">    private boolean needGenDAO = true;</span><br><span class="line"></span><br><span class="line">    public boolean isNeedGenPresentation()&#123;</span><br><span class="line">        return needGenPresentation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isNeedGenBusiness()&#123;</span><br><span class="line">        return needGenBusiness;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isNeedGenDAO()&#123;</span><br><span class="line">        return needGenDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNeedGenPresentation(boolean needGenPresentation) &#123;</span><br><span class="line">        this.needGenPresentation = needGenPresentation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNeedGenBusiness(boolean needGenBusiness) &#123;</span><br><span class="line">        this.needGenBusiness = needGenBusiness;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNeedGenDAO(boolean needGenDAO) &#123;</span><br><span class="line">        this.needGenDAO = needGenDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）接着是配置管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigManager &#123;</span><br><span class="line">    private static ConfigManager manager = null;</span><br><span class="line">    private static ConfigModel cm = null;</span><br><span class="line"></span><br><span class="line">    private ConfigManager()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ConfigManager getInstance()&#123;</span><br><span class="line">        if( manager == null)&#123;</span><br><span class="line">            manager = new ConfigManager();</span><br><span class="line">            cm = new ConfigModel();</span><br><span class="line">        &#125;</span><br><span class="line">        return manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConfigModel getConfigData()&#123;</span><br><span class="line">        return cm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3)再看看各个生成代码的模块，示例代码如下：<br/><br>先来看表现层的示意实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Presentation &#123;</span><br><span class="line">    public void generate()&#123;</span><br><span class="line">        //从配置管理中获取相应的配置信息</span><br><span class="line">        ConfigModel cm = ConfigManager.getInstance().getConfigData();</span><br><span class="line">        if(cm.isNeedGenPresentation())&#123;</span><br><span class="line">            System.out.println(&quot;正在生成表现层代码文件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看逻辑层的示意实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Business &#123;</span><br><span class="line">    public void generate()&#123;</span><br><span class="line">        //从配置管理中获取相应的配置信息</span><br><span class="line">        ConfigModel cm = ConfigManager.getInstance().getConfigData();</span><br><span class="line">        if(cm.isNeedGenBusiness())&#123;</span><br><span class="line">            System.out.println(&quot;正在生成逻辑层代码文件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是数据层的示意实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DAO &#123;</span><br><span class="line">    public void generate()&#123;</span><br><span class="line">        //从配置管理中获取相应的配置信息</span><br><span class="line">        ConfigModel cm = ConfigManager.getInstance().getConfigData();</span><br><span class="line">        if(cm.isNeedGenDAO())&#123;</span><br><span class="line">            System.out.println(&quot;正在生成数据层代码文件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(4)此时的客户端实现，就是去调用多个代码生成模块了，示意代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">//为了生成代码，客户端需要对三个模块都要了解，知道要如何生成才可，耦合度太高</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Presentation().generate();</span><br><span class="line">        new Business().generate();</span><br><span class="line">        new DAO().generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-2-分析问题"><a href="#1-2-分析问题" class="headerlink" title="1.2 分析问题"></a>1.2 分析问题</h2><p>可以看到在上例中，客户端为了使用生成代码的功能，需要与生成多个代码子模块进行交互，耦合度过高。如果其中的子模块变化了，那么客户端生成的代码也需要相应进行变化。</p>
<h1 id="2-带模式的解决方案"><a href="#2-带模式的解决方案" class="headerlink" title="2 带模式的解决方案"></a>2 带模式的解决方案</h1><h2 id="2-1-外观模式重写示例"><a href="#2-1-外观模式重写示例" class="headerlink" title="2.1 外观模式重写示例"></a>2.1 外观模式重写示例</h2><p>如何理解外观：外观就是从这个组件外部来看有统一的界面，就像是电脑主板的初始化一样，不用管网卡初始化，声卡初始化或者内存初始化，使用者只要知道主板初始化就好，不需要知道初始化的具体细节。<br/><br>（1）新添加一个Facade对象，用于作为外观模式的界面，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Facade &#123;</span><br><span class="line">   public void generate()&#123;</span><br><span class="line">       new Presentation().generate();</span><br><span class="line">       new Business().generate();</span><br><span class="line">       new DAO().generate();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）其他定义和实现都没有变化，包括ConfigModel,ConfigManager,Presentation,Business,DAO<br/><br>（3）此时的客户端如何实现，直接调用外观对象即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Facade().generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-外观模式分析"><a href="#2-2-外观模式分析" class="headerlink" title="2.2 外观模式分析"></a>2.2 外观模式分析</h2><p>通过上例可以看出，主要变化就是新增了一个外观接口，将客户端的代码搬到了该接口中。<br/><br>优点有以下几点：<br/><br>（1）将三个代码生成模块组合成一个整体，方便了客户端的调用，而且封装了系统内部的细节功能<br/><br>（2）将三个模块封装在一起之后，就如同方法一样，可以实现复用，方便了多个客户端进行调用<br/><br>（3）对于使用Facade的人员来说，大大降低了学习的难度，就如同电脑主板一样，不需要知道网卡，声卡还有内存如何搭配一样。</p>
<h1 id="3-思考外观模式"><a href="#3-思考外观模式" class="headerlink" title="3 思考外观模式"></a>3 思考外观模式</h1><h2 id="3-1-何时选用外观模式"><a href="#3-1-何时选用外观模式" class="headerlink" title="3.1 何时选用外观模式"></a>3.1 何时选用外观模式</h2><p>（1）若希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式。使用外观对象来实现大部分客户需要的功能，从而简化客户的使用。<br/><br>（2）构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。例如JAVAEE三层架构中，界面层，业务层和数据层之间就可以用此模式，相互之间调用接口，实现隔离。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%A0%94%E7%A3%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%A0%94%E7%A3%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：研磨设计模式笔记之简单工厂模式"><a href="#原创：研磨设计模式笔记之简单工厂模式" class="headerlink" title="原创：研磨设计模式笔记之简单工厂模式"></a>原创：研磨设计模式笔记之简单工厂模式</h1><h1 id="1-不用模式的解决方案"><a href="#1-不用模式的解决方案" class="headerlink" title="1.不用模式的解决方案"></a>1.不用模式的解决方案</h1><h2 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h2><p>(1)首先定义接口Api,示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Api &#123;</span><br><span class="line">    public void test1(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)有了Api，自然要有实现，此处功能为输出字符串，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImplA implements  Api&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test1(String s) &#123;</span><br><span class="line">        System.out.println(&quot;Now In Impl. The input s == &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3)客户端调用实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Api api = new ImplA();</span><br><span class="line">        api.test1(&quot;哈哈，不要紧张，只是一个测试而已！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-2-分析问题"><a href="#1-2-分析问题" class="headerlink" title="1.2 分析问题"></a>1.2 分析问题</h2><p>可以看到上例中，客户端已经知道了相应的实现，所以根本没有做到“封装隔离”。<br/><br>要做到“封装隔离”，客户端就不应该知道具体的实现是什么，那么“new Impl()”就应该封装起来，让客户端看不到。</p>
<h1 id="2-带模式的解决方案"><a href="#2-带模式的解决方案" class="headerlink" title="2.带模式的解决方案"></a>2.带模式的解决方案</h1><h2 id="2-1-简单工厂重写示例"><a href="#2-1-简单工厂重写示例" class="headerlink" title="2.1 简单工厂重写示例"></a>2.1 简单工厂重写示例</h2><p>（1）Api与相应实现Impl都与上面相同<br/><br>此处主要说一下简单工厂Factory，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Factory &#123;</span><br><span class="line">	//返回的实例包裹在Factory中，这样客户端就看不到了</span><br><span class="line">    public static Api create()&#123;</span><br><span class="line">        return new ImplA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）重写客户端代码，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	//这个时候就不用显式写出new Impl()，而是通过工厂来返回</span><br><span class="line">        Api api = Factory.create();</span><br><span class="line">        api.test1(&quot;正在测试重写简单工厂。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从客户端来看，不需要知道具体的实现是什么，也不需要知道如何实现的，只知道从工厂获得了一个接口对象，然后通过接口来获取想要的功能。</p>
<h2 id="2-2-带选择的简单工厂"><a href="#2-2-带选择的简单工厂" class="headerlink" title="2.2 带选择的简单工厂"></a>2.2 带选择的简单工厂</h2><p>上面重写示例中，只有一种实现，要是有多种实现又该如何呢？<br/><br>（1）Api和相应实现不变<br/><br>在上面的基础上再添加一种实现ImplB,代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImplB implements Api &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation(String s) &#123;</span><br><span class="line">        System.out.println(&quot;ImplB s == &quot;+ s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)修改简单工厂Factory,做到选择实现，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Factory &#123;</span><br><span class="line">    public static Api create(int condition)&#123;</span><br><span class="line">        Api api = null;</span><br><span class="line">        if(condition == 1)&#123;</span><br><span class="line">            api = new ImplA();</span><br><span class="line">        &#125;else if(condition == 2)&#123;</span><br><span class="line">            api = new ImplB();</span><br><span class="line">        &#125;</span><br><span class="line">        return api;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3)修改客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    //客户端通过1或者2,来选择相应的实现</span><br><span class="line">        Api api = Factory.create(1);</span><br><span class="line">        api.operation(&quot;正在使用简单工厂&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-带选择的简单工厂的缺陷"><a href="#2-3-带选择的简单工厂的缺陷" class="headerlink" title="2.3 带选择的简单工厂的缺陷"></a>2.3 带选择的简单工厂的缺陷</h2><p>带选择的简单工厂有很大的局限性，如果有多重选择，那么就要在工厂中多次判断，复杂性大大提升。另外从客户端调用工厂的时候传入选择的参数，增加了硬编码。<br/><br>这种复杂性不能放在代码中来判断，而应该放在外部，从代码中独立出来，放在配置中。</p>
<h2 id="2-4-可配置的简单工厂"><a href="#2-4-可配置的简单工厂" class="headerlink" title="2.4 可配置的简单工厂"></a>2.4 可配置的简单工厂</h2><p>(1)配置文件用properties文件，定义一个“FactoryTest.properties”文件放在工厂类的同一个包下，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImplClass=com.zte.rewriteonproperties.ImplA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)修改工厂类Factory,代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Factory &#123;</span><br><span class="line">    </span><br><span class="line">    public static Api createApi()&#123;</span><br><span class="line">    	Properties p = new Properties();</span><br><span class="line">    	InputStream in = null;</span><br><span class="line">    	//读取配置文件</span><br><span class="line">        in = Factory.class.getResourceAsStream(&quot;FactoryTest.properties&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            p.load(in);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(&quot;装载工厂配置文件出错了，具体的堆栈信息如下：&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            //读取完毕，要记住关流</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Api api = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            //反射创建实例</span><br><span class="line">                api =(Api)Class.forName(p.getProperty(&quot;ImplClass&quot;)).newInstance();</span><br><span class="line">            &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return api;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）客户端代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    //可以看到，此时就不需要传入参数，复杂性直接转移到配置文件中控制</span><br><span class="line">        Api api = Factory.createApi();</span><br><span class="line">        api.test1(&quot;哈哈哈，不要紧张，测试而已！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-思考简单工厂"><a href="#3-思考简单工厂" class="headerlink" title="3.思考简单工厂"></a>3.思考简单工厂</h1><p>本人还处于学习阶段，在使用简单工厂方面还缺少经验。<br/><br>根据我的理解，在同一个功能有多重实现的时候，就可以选用简单工厂，一方面能够做到接口隔离，另一方面能够做到选择实现，集中管理和控制。<br/><br>举个例子，同样的打印功能，可以用爱普生的，或者惠普的。这些打印厂家都实现了打印标准，同一接口。<br/><br>(1)首先有个同一的接口Print</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Print&#123;</span><br><span class="line">	public void print(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)然后再有多个实现EpsonImpl,HpImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class EpsonImpl implements Print&#123;</span><br><span class="line">	public void print(String s)&#123;</span><br><span class="line">		System.out.println(&quot;this is EpsonPrinter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HpImpl implements Print&#123;</span><br><span class="line">	public void print(String s)&#123;</span><br><span class="line">		System.out.println(&quot;this is EpsonPrinter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再之后就可以从多个实现中做出选择，完成打印功能的隔离。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/31/%E5%8E%9F%E5%88%9B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原创：线程的调度方式"><a href="#原创：线程的调度方式" class="headerlink" title="原创：线程的调度方式"></a>原创：线程的调度方式</h1><h1 id="线程的调度方式"><a href="#线程的调度方式" class="headerlink" title="线程的调度方式"></a>线程的调度方式</h1><p>  在一个进程里，线程的调度有抢占式和非抢占式的模式。</p>
<h2 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h2><p>  在抢占模式下，操作系统负责分配CPU时间给各个进程，一旦当前的进程使用完分配给自己的CPU时间，操作系统将决定下一个占用CPU时间的是哪一个线程。因此操作系统将定期的中断当前正在执行的线程，将CPU分配给在等待队列的下一个线程。所以任何一个线程都不能独占CPU。每个线程占用CPU的时间取决于进程和操作系统。进程分配给每个线程的时间很短，以至于我们感觉所有的线程是同时执行的。实际上，系统运行每个进程的时间有2毫秒，然后调度其他的线程，它同时维持着所有的线程和循环，分配很少量的CPU时间给线程。<br/><br>  调度是什么意思？调度意味着处理器存储着将要执行完CPU时间的进程的状态和将来某个时间装载这个进程的状态而恢其运行。<br/><br>  抢占式有不足之处，一个线程可以在任何给定的时间中断另外一个线程的执行。假设一个线程正在向一个文件做写入操作，而另外一个线程中断其运行，也向同一个文件做写操作，就会出现写入问题。</p>
<h2 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h2><p>  在非抢占式调度模式下，每个线程可以需要CPU多少时间就占用CPU多少时间。在这种调度方式下，可能一个执行时间很长的线程使得其他所有需要CPU的线程“饿死”。在处理机空闲，即该进程没有使用CPU时，系统可以允许其他的进程暂时使用CPU。占用CPU 的线程拥有对CPU的控制权，只有它自己主动释放CPU时，其他的线程才可以使用CPU。</p>
<h2 id="何时用"><a href="#何时用" class="headerlink" title="何时用"></a>何时用</h2><p>  在有些操作系统里面，这两种调度策略都会用到。<br/><br>  非抢占的调度策略在线程运行优先级一般时用到，而对于高优先级的线程调度则多采用抢占式的调度策略。如果你不确定系统采用的是哪种调度策略，假设抢占的调度策略不可用是比较安全的。（前面说明了，文件写入影响很大）<br/><br>  在设计应用程序的时候，我们认为那些占用CPU时间比较多的线程在一定的间隔是会释放CPU的控制权的，这时候系统会查看那些在等候队列里面的与当前执行的线程同一优先级或者更高的优先级的线程，而让这些线程得以使用CPU。如果系统找到一个这样的线程，就立刻暂停当前执行的线程和激活满足条件的线程。如果没有找到同一优先级或更高级的线程，当前线程还继续占有CPU。当正在执行的线程想释放CPU的控制权给一个低优先级的线程，当前线程就转入睡眠状态而让低优先级的线程占有CPU。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
