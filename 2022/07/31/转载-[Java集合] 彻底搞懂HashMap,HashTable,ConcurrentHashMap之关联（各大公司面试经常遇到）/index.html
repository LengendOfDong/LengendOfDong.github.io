<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lengendofdong.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）注: 今天看到的一篇讲hashMap,hashTable,concurrentHashMap很透彻的一篇文章, 感谢原作者的分享. 原文地址: http:&#x2F;&#x2F;blog.csdn.net&#x2F;zhangerqing&#x2F;article&#x2F;details&#x2F;8193118 Java集">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[Java%E9%9B%86%E5%90%88]%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）注: 今天看到的一篇讲hashMap,hashTable,concurrentHashMap很透彻的一篇文章, 感谢原作者的分享. 原文地址: http:&#x2F;&#x2F;blog.csdn.net&#x2F;zhangerqing&#x2F;article&#x2F;details&#x2F;8193118 Java集">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-my.csdn.net/uploads/201211/17/1353118778_2052.png">
<meta property="article:published_time" content="2022-07-31T07:58:18.341Z">
<meta property="article:modified_time" content="2022-07-31T07:51:32.949Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-my.csdn.net/uploads/201211/17/1353118778_2052.png">


<link rel="canonical" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[Java%E9%9B%86%E5%90%88]%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[Java%E9%9B%86%E5%90%88]%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/","path":"2022/07/31/转载-[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="history fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="list fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-tools"><a href="/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/" rel="section"><i class="briefcase fa-fw"></i>tools</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>About</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AC%E8%BD%BD%EF%BC%9A-Java%E9%9B%86%E5%90%88-%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap-HashTable-ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="John Doe"
      src="/images/1.webp">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">136</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://lengendofdong.github.io/2022/07/31/%E8%BD%AC%E8%BD%BD-[Java%E9%9B%86%E5%90%88]%20%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82HashMap,HashTable,ConcurrentHashMap%E4%B9%8B%E5%85%B3%E8%81%94%EF%BC%88%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.webp">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-07-31 15:58:18 / Modified: 15:51:32" itemprop="dateCreated datePublished" datetime="2022-07-31T15:58:18+08:00">2022-07-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="转载：-Java集合-彻底搞懂HashMap-HashTable-ConcurrentHashMap之关联（各大公司面试经常遇到）"><a href="#转载：-Java集合-彻底搞懂HashMap-HashTable-ConcurrentHashMap之关联（各大公司面试经常遇到）" class="headerlink" title="转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）"></a>转载：[Java集合] 彻底搞懂HashMap,HashTable,ConcurrentHashMap之关联（各大公司面试经常遇到）</h1><p>注: 今天看到的一篇讲hashMap,hashTable,concurrentHashMap很透彻的一篇文章, 感谢原作者的分享. <br/><br>原文地址: <a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangerqing/article/details/8193118">http://blog.csdn.net/zhangerqing/article/details/8193118</a> <br/><br><br/><br>Java集合类是个非常重要的知识点，HashMap、HashTable、ConcurrentHashMap等算是集合类中的重点，可谓“重中之重”，首先来看个问题，如面试官问你：HashMap和HashTable有什么区别，一个比较简单的回答是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。</p>
<p>能答出上面的三点，简单的面试，算是过了，但是如果再问：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？能把第二个问题完整的答出来，说明你的基础算是不错的了。带着这个问题，本章开始系<strong>Java之美[从菜鸟到高手演变]系列</strong>之深入解析HashMap和HashTable类应用而生！总想在文章的开头说点儿什么，但又无从说起。从最近的一些面试说起吧，感受就是：知识是永无止境的，永远不要觉得自己已经掌握了某些东西。如果对哪一块知识感兴趣，那么，请多多的花时间，哪怕最基础的东西也要理解它的原理，尽量往深了研究，在学习的同时，记得多与大家交流沟通，因为也许某些东西，从你自己的角度，是很难发现的，因为你并没有那么多的实验环境去发现他们。只有交流的多了，才能及时找出自己的不足，才能认识到：“哦，原来我还有这么多不知道的东西！”。</p>
<p><strong>一、HashMap的内部存储结构</strong> <br/><br>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表，数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。而链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。有没有一种数据结构来综合一下数组和链表，以便发挥他们各自的优势？答案是肯定的！就是：哈希表。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”，如下图：</p>
<img alt="" src="https://img-my.csdn.net/uploads/201211/17/1353118778_2052.png"/>


<p>从上图中，我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16&#x3D;12,28%16&#x3D;12,108%16&#x3D;12,140%16&#x3D;12。所以12、28、108以及140都存储在数组下标为12的位置。它的内部其实是用一个Entity数组来实现的，属性有key、value、next。接下来我会从初始化阶段详细的讲解HashMap的内部结构。</p>
<p><strong><em>1、初始化 <br/><br></em></strong>首先来看三个常量： <br/><br>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16; 初始容量：16 <br/><br>static final int MAXIMUM_CAPACITY &#x3D; 1  <br/><br>&lt;&lt; 30; 最大容量：2的30次方：1073741824 <br/><br>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;  <br/><br>装载因子，后面再说它的作用 <br/><br>来看个无参构造方法，也是我们最常用的：</p>
<li>
public HashMap() {  </li><li>
        this.loadFactor = DEFAULT_LOAD_FACTOR;  </li><li>
        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);  </li><li>
        table = new Entry[DEFAULT_INITIAL_CAPACITY];  </li><li>
        init();  </li><li>
    }  </li>

<p>loadFactor、threshold的值在此处没有起到作用，不过他们在后面的扩容方面会用到，此处只需理解table&#x3D;new Entry[DEFAULT_INITIAL_CAPACITY].说明，默认就是开辟16个大小的空间。另外一个重要的构造方法：</p>
<li>
public HashMap(int initialCapacity, float loadFactor) {  </li><li>
        if (initialCapacity &lt; 0)  </li><li>
            throw new IllegalArgumentException("Illegal initial capacity: " +  </li><li>
                                               initialCapacity);  </li><li>
        if (initialCapacity &gt; MAXIMUM_CAPACITY)  </li><li>
            initialCapacity = MAXIMUM_CAPACITY;  </li><li>
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </li><li>
            throw new IllegalArgumentException("Illegal load factor: " +  </li><li>
                                               loadFactor);  </li><li>
  </li><li>
        // Find a power of 2 &gt;= initialCapacity  </li><li>
        int capacity = 1;  </li><li>
        while (capacity &lt; initialCapacity)  </li><li>
            capacity &lt;&lt;= 1;  </li><li>
  </li><li>
        this.loadFactor = loadFactor;  </li><li>
        threshold = (int)(capacity * loadFactor);  </li><li>
        table = new Entry[capacity];  </li><li>
        init();  </li><li>
    }  </li>

<br/>
就是说传入参数的构造方法，我们把重点放在：

<li>
while (capacity &lt; initialCapacity)  </li><li>
           capacity &lt;&lt;= 1;  </li>

<br/>
上面，该代码的意思是，实际的开辟的空间要大于传入的第一个参数的值。举个例子：<br/>
new HashMap(7,0.8),loadFactor为0.8，capacity为7，通过上述代码后，capacity的值为：8.（1 &lt;&lt; 2的结果是4,2 &lt;&lt; 2的结果为8&lt;此处感谢网友wego1234的指正&gt;）。所以，最终capacity的值为8，最后通过new Entry[capacity]来创建大小为capacity的数组，所以，这种方法最红取决于capacity的大小。<br/>
<em><strong>2、put(Object key,Object value)操作<br/>
</strong></em> <br/>
当调用put操作时，首先判断key是否为null，如下代码1处：

<li>
&lt;p&gt;public V put(K key, V value) {  </li><li>
        if (key == null)  </li><li>
            return putForNullKey(value);  </li><li>
        int hash = hash(key.hashCode());  </li><li>
        int i = indexFor(hash, table.length);  </li><li>
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }&lt;/p&gt;&lt;p&gt;        modCount++;  </li><li>
        addEntry(hash, key, value, i);  </li><li>
        return null;  </li><li>
    }&lt;/p&gt;  </li>

<br/>
如果**key是null**，则调用如下代码：

<li>
private V putForNullKey(V value) {  </li><li>
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {  </li><li>
            if (e.key == null) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }  </li><li>
        modCount++;  </li><li>
        addEntry(0, null, value, 0);  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
就是说，获取Entry的第一个元素table[0]，并基于第一个元素的next属性开始遍历，直到找到key为null的Entry，将其value设置为新的value值。<br/>
如果没有找到key为null的元素，则调用如上述代码的addEntry(0, null, value, 0);增加一个新的entry，代码如下：

<li>
void addEntry(int hash, K key, V value, int bucketIndex) {  </li><li>
    Entry&lt;K,V&gt; e = table[bucketIndex];  </li><li>
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </li><li>
        if (size++ &gt;= threshold)  </li><li>
            resize(2 * table.length);  </li><li>
    }  </li>

<br/>
先获取第一个元素table[bucketIndex],传给e对象，新建一个entry，key为null，value为传入的value值，next为获取的e对象。如果容量大于threshold，容量扩大2倍。<br/>
如果**key不为null**，这也是大多数的情况，重新看一下源码：

<li>
public V put(K key, V value) {  </li><li>
        if (key == null)  </li><li>
            return putForNullKey(value);  </li><li>
        int hash = hash(key.hashCode());//---------------2---------------  </li><li>
        int i = indexFor(hash, table.length);  </li><li>
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {//--------------3-----------  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li><li>
                V oldValue = e.value;  </li><li>
                e.value = value;  </li><li>
                e.recordAccess(this);  </li><li>
                return oldValue;  </li><li>
            }  </li><li>
        }//-------------------4------------------  </li><li>
        modCount++;//----------------5----------  </li><li>
        addEntry(hash, key, value, i);-------------6-----------  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
看源码中2处，首先会进行key.hashCode()操作，获取key的哈希值，hashCode()是Object类的一个方法，为本地方法，内部实现比较复杂，我们<br/>
会在后面作单独的关于Java中Native方法的分析中介绍。hash()的源码如下：

<li>
static int hash(int h) {  </li><li>
        // This function ensures that hashCodes that differ only by  </li><li>
        // constant multiples at each bit position have a bounded  </li><li>
        // number of collisions (approximately 8 at default load factor).  </li><li>
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </li><li>
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </li><li>
    }  </li>

<p>int i &#x3D; indexFor(hash, table.length);的意思，相当于int i &#x3D; hash % Entry[].length;得到i后，就是在Entry数组中的位置，（<del>上述代码5和6处是如果Entry数组中不存在新要增加的元素，则执行5,6处的代码，如果存在，即Hash冲突，则执行 3-4处的代码，此处HashMap中采用链地址法解决Hash冲突</del>。此处经网友<strong>bbycszh</strong>指正，发现上述陈述有些问题）。重新解释：其实不管Entry数组中i位置有无元素，都会去执行5-6处的代码，如果没有，则直接新增，如果有，则将新元素设置为Entry[0]，其next指针指向原有对象，即原有对象为Entry[1]。具体方法可以解释为下面的这段文字：（<strong>3-4处的代码只是检查在索引为i的这条链上有没有key重复的，有则替换且返回原值，程序不再去执行5-6处的代码，无则无处理</strong>）</p>
<p>上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。如， 第一个键值对A进来，通过计算其key的hash得到的i&#x3D;0，记做:Entry[0] &#x3D; A。一会后又进来一个键值对B，通过计算其i也等于0，现在怎么办？HashMap会这样做:B.next &#x3D; A,Entry[0] &#x3D; B,如果又进来C,i也等于0,那么C.next &#x3D; B,Entry[0] &#x3D; C；这样我们发现i&#x3D;0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,也就是说数组中存储的是最后插入的元素。</p>
<p>到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。<br/></p>
<p><strong><strong>2、get(Object key)操作</strong></strong><br/><br>get(Object key)操作时根据键来获取值，如果了解了put操作，get操作容易理解，先来看看源码的实现：</p>
<li>
public V get(Object key) {  </li><li>
        if (key == null)  </li><li>
            return getForNullKey();  </li><li>
        int hash = hash(key.hashCode());  </li><li>
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </li><li>
             e != null;  </li><li>
             e = e.next) {  </li><li>
            Object k;  </li><li>
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))//-------------------1----------------  </li><li>
                return e.value;  </li><li>
        }  </li><li>
        return null;  </li><li>
    }  </li>

<br/>
意思就是：1、当key为null时，调用getForNullKey()，源码如下：

<li>
private V getForNullKey() {  </li><li>
        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {  </li><li>
            if (e.key == null)  </li><li>
                return e.value;  </li><li>
        }  </li><li>
        return null;  </li><li>
    }  </li>

<p>2、当key不为null时，先根据hash函数得到hash值，在更具indexFor()得到i的值，循环遍历链表，如果有：key值等于已存在的key值，则返回其value。如上述get()代码1处判断。</p>
<p>总结下HashMap新增put和获取get操作：</p>
<li>
//存储时:  </li><li>
int hash = key.hashCode();  </li><li>
int i = hash % Entry[].length;  </li><li>
Entry[i] = value;  </li><li>
  </li><li>
//取值时:  </li><li>
int hash = key.hashCode();  </li><li>
int i = hash % Entry[].length;  </li><li>
return Entry[i];  </li>

<p>理解了就比较简单。</p>
<p>此处附一个简单的HashMap小算法应用：</p>
<li>
package com.xtfggef.hashmap;  </li><li>
  </li><li>
import java.util.HashMap;  </li><li>
import java.util.Map;  </li><li>
import java.util.Set;  </li><li>
  </li><li>
/** </li><li>
 * 打印在数组中出现n/2以上的元素 </li><li>
 * 利用一个HashMap来存放数组元素及出现的次数 </li><li>
 * @author erqing </li><li>
 * </li><li>
 */  </li><li>
public class HashMapTest {  </li><li>
      </li><li>
    public static void main(String[] args) {  </li><li>
          </li><li>
        int [] a = {2,3,2,2,1,4,2,2,2,7,9,6,2,2,3,1,0};  </li><li>
          </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();  </li><li>
        for(int i=0; i&lt;a.length; i++){  </li><li>
            if(map.containsKey(a[i])){  </li><li>
                int tmp = map.get(a[i]);  </li><li>
                tmp+=1;  </li><li>
                map.put(a[i], tmp);  </li><li>
            }else{  </li><li>
                map.put(a[i], 1);  </li><li>
            }  </li><li>
        }  </li><li>
        Set&lt;Integer&gt; set = map.keySet();//------------1------------  </li><li>
        for (Integer s : set) {  </li><li>
            if(map.get(s)&gt;=a.length/2){  </li><li>
                System.out.println(s);  </li><li>
            }  </li><li>
        }//--------------2---------------  </li><li>
    }  </li><li>
}  </li>

<p>此处注意两个地方，map.containsKey()，还有就是上述1-2处的代码。</p>
<p>理解了HashMap的上面的操作，其它的大多数方法都很容易理解了。搞清楚它的内部存储机制，一切OK！<br/></p>
<p><strong>二、HashTable的内部存储结构</strong></p>
<p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>
<p>2、HashTable不允许有null值的存在。</p>
<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>
<p><strong>三、HashTable和ConcurrentHashMap的比较</strong></p>
<p>如我开篇所说一样，ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？</p>
<p>之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，<strong>锁住的都是对象整体</strong>，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。关于concurrentLevel稍后介绍。</p>
<p><strong><strong>1、构造方法</strong></strong></p>
<p>为了容易理解，我们先从构造函数说起。ConcurrentHashMap是基于一个叫Segment数组的，其实和Entry类似，如下：</p>
<li>
public ConcurrentHashMap()  </li><li>
  {  </li><li>
    this(16, 0.75F, 16);  </li><li>
  }  </li>

<br/>
默认传入值16，调用下面的方法：

<li>
public ConcurrentHashMap(int paramInt1, float paramFloat, int paramInt2)  </li><li>
  {  </li><li>
    if ((paramFloat &lt;= 0F) || (paramInt1 &lt; 0) || (paramInt2 &lt;= 0))  </li><li>
      throw new IllegalArgumentException();  </li><li>
  </li><li>
    if (paramInt2 &gt; 65536) {  </li><li>
      paramInt2 = 65536;  </li><li>
    }  </li><li>
  </li><li>
    int i = 0;  </li><li>
    int j = 1;  </li><li>
    while (j &lt; paramInt2) {  </li><li>
      ++i;  </li><li>
      j &lt;&lt;= 1;  </li><li>
    }  </li><li>
    this.segmentShift = (32 - i);  </li><li>
    this.segmentMask = (j - 1);  </li><li>
    this.segments = Segment.newArray(j);  </li><li>
  </li><li>
    if (paramInt1 &gt; 1073741824)  </li><li>
      paramInt1 = 1073741824;  </li><li>
    int k = paramInt1 / j;  </li><li>
    if (k * j &lt; paramInt1)  </li><li>
      ++k;  </li><li>
    int l = 1;  </li><li>
    while (l &lt; k)  </li><li>
      l &lt;&lt;= 1;  </li><li>
  </li><li>
    for (int i1 = 0; i1 &lt; this.segments.length; ++i1)  </li><li>
      this.segments[i1] = new Segment(l, paramFloat);  </li><li>
  }  </li>

<br/>
你会发现比HashMap的构造函数多一个参数，paramInt1就是我们之前谈过的initialCapacity，就是数组的初始化大小，paramfloat为loadFactor（装载因子），而paramInt2则是我们所要说的concurrentLevel，这三个值分别被初始化为16,0.75,16，经过：

<li>
while (j &lt; paramInt2) {  </li><li>
      ++i;  </li><li>
      j &lt;&lt;= 1;  </li><li>
    }  </li>

<br/>
后，j就是我们最终要开辟的数组的size值，当paramInt1为16时，计算出来的size值就是16.通过：


<p>this.segments &#x3D; Segment.newArray(j)后，我们看出了，最终稿创建的Segment数组的大小为16.最终创建Segment对象时：</p>
<li>
this.segments[i1] = new Segment(cap, paramFloat);  </li>

<p>需要cap值，而cap值来源于：</p>
<li>
int k = paramInt1 / j;  </li><li>
  if (k * j &lt; paramInt1)  </li><li>
    ++k;  </li><li>
  int cap = 1;  </li><li>
  while (cap &lt; k)  </li><li>
    cap &lt;&lt;= 1;  </li>

<p>组后创建大小为cap的数组。最后根据数组的大小及paramFloat的值算出了threshold的值：</p>
<p>this.threshold &#x3D; (int)(paramArrayOfHashEntry.length * this.loadFactor)。</p>
<p><strong><strong>2、put操作</strong></strong></p>
<li>
public V put(K paramK, V paramV)  </li><li>
  {  </li><li>
    if (paramV == null)  </li><li>
      throw new NullPointerException();  </li><li>
    int i = hash(paramK.hashCode());  </li><li>
    return segmentFor(i).put(paramK, i, paramV, false);  </li><li>
  }  </li>

<br/>
与HashMap不同的是，如果key为null，直接抛出NullPointer异常，之后，同样先计算hashCode的值，再计算hash值，不过此处hash函数和HashMap中的不一样：

<li>
private static int hash(int paramInt)  </li><li>
  {  </li><li>
    paramInt += (paramInt &lt;&lt; 15 ^ 0xFFFFCD7D);  </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 10;  </li><li>
    paramInt += (paramInt &lt;&lt; 3);  </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 6;  </li><li>
    paramInt += (paramInt &lt;&lt; 2) + (paramInt &lt;&lt; 14);  </li><li>
    return (paramInt ^ paramInt &gt;&gt;&gt; 16);  </li><li>
  }  </li>

<br/>
 

<li>
final Segment&lt;K, V&gt; segmentFor(int paramInt)  </li><li>
  {  </li><li>
    return this.segments[(paramInt &gt;&gt;&gt; this.segmentShift &amp; this.segmentMask)];  </li><li>
  }  </li>

<br/>
根据上述代码找到Segment对象后，调用put来操作：

<li>
V put(K paramK, int paramInt, V paramV, boolean paramBoolean)  </li><li>
{  </li><li>
  lock();  </li><li>
  try {  </li><li>
    Object localObject1;  </li><li>
    Object localObject2;  </li><li>
    int i = this.count;  </li><li>
    if (i++ &gt; this.threshold)  </li><li>
      rehash();  </li><li>
    ConcurrentHashMap.HashEntry[] arrayOfHashEntry = this.table;  </li><li>
    int j = paramInt &amp; arrayOfHashEntry.length - 1;  </li><li>
    ConcurrentHashMap.HashEntry localHashEntry1 = arrayOfHashEntry[j];  </li><li>
    ConcurrentHashMap.HashEntry localHashEntry2 = localHashEntry1;  </li><li>
    while ((localHashEntry2 != null) &amp;&amp; (((localHashEntry2.hash != paramInt) || (!(paramK.equals(localHashEntry2.key)))))) {  </li><li>
      localHashEntry2 = localHashEntry2.next;  </li><li>
    }  </li><li>
  </li><li>
    if (localHashEntry2 != null) {  </li><li>
      localObject1 = localHashEntry2.value;  </li><li>
      if (!(paramBoolean))  </li><li>
        localHashEntry2.value = paramV;  </li><li>
    }  </li><li>
    else {  </li><li>
      localObject1 = null;  </li><li>
      this.modCount += 1;  </li><li>
      arrayOfHashEntry[j] = new ConcurrentHashMap.HashEntry(paramK, paramInt, localHashEntry1, paramV);  </li><li>
      this.count = i;  </li><li>
    }  </li><li>
    return localObject1;  </li><li>
  } finally {  </li><li>
    unlock();  </li><li>
  }  </li><li>
}  </li>

<br/>
先调用lock()，lock是ReentrantLock类的一个方法，用当前存储的个数+1来和threshold比较，如果大于threshold，则进行rehash，将当前的容量扩大2倍，重新进行hash。之后对hash的值和数组大小-1进行按位于操作后，得到当前的key需要放入的位置，从这儿开始，和HashMap一样。


<p>从上述的分析看出，<strong><strong>ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</strong></strong></p>
<p>在多线程的环境中，相对于HashTable，ConcurrentHashMap会带来很大的性能提升！</p>
<p><strong><u>欢迎读者批评指正，有任何建议请联系:</u></strong></p>
<p><strong><u>EGG：<a href="mailto:&#120;&#x74;&#x66;&#x67;&#x67;&#101;&#x66;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#120;&#x74;&#x66;&#x67;&#x67;&#101;&#x66;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a>      <a target="_blank" rel="noopener" href="http://weibo.com/xtfggef">http://weibo.com/xtfggef</a></u></strong></p>
<p><strong>四、HashMap常见问题分析</strong></p>
<p><strong><strong>1、此处我觉得</strong></strong>网友**<a href="mailto:huxb23@126">huxb23@126</a>**的一篇文章说的很好，<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/"><strong>分析多线程并发写HashMap线程被hang住的原因</strong></a> ，因为是优秀的资源，此处我整理下搬到这儿。</p>
<p>以下内容转自博文：<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/">http:&#x2F;&#x2F;blog.163.com&#x2F;huxb23@126&#x2F;blog&#x2F;static&#x2F;625898182011211318854&#x2F;</a> </p>
<p>先看原问题代码：</p>
<li>
import java.util.HashMap;  </li><li>
  </li><li>
public class TestLock {  </li><li>
  </li><li>
    private HashMap map = new HashMap();  </li><li>
  </li><li>
    public TestLock() {  </li><li>
        Thread t1 = new Thread() {  </li><li>
            public void run() {  </li><li>
                for (int i = 0; i &lt; 50000; i++) {  </li><li>
                    map.put(new Integer(i), i);  </li><li>
                }  </li><li>
                System.out.println("t1 over");  </li><li>
            }  </li><li>
        };  </li><li>
  </li><li>
        Thread t2 = new Thread() {  </li><li>
            public void run() {  </li><li>
                for (int i = 0; i &lt; 50000; i++) {  </li><li>
                    map.put(new Integer(i), i);  </li><li>
                }  </li><li>
  </li><li>
                System.out.println("t2 over");  </li><li>
            }  </li><li>
        };  </li><li>
  </li><li>
        t1.start();  </li><li>
        t2.start();  </li><li>
  </li><li>
    }  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
        new TestLock();  </li><li>
    }  </li><li>
}  </li>

<br/>
就是启了两个线程，不断的往一个非线程安全的HashMap中put内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会两个线程都被hang住。说到这里，你如果觉得不好好学习ConcurrentHashMap而在这瞎折腾就手下留情跳过吧。<br/>
好吧，分析下HashMap的put函数源码看看问题出在哪，这里就罗列出相关代码（jdk1.6）：

<li>
public V put(K paramK, V paramV)  </li><li>
{  </li><li>
  if (paramK == null)  </li><li>
    return putForNullKey(paramV);  </li><li>
  int i = hash(paramK.hashCode());  </li><li>
  int j = indexFor(i, this.table.length);  </li><li>
  for (Entry localEntry = this.table[j]; localEntry != null; localEntry = localEntry.next)  </li><li>
  {  </li><li>
    if (localEntry.hash == i) { java.lang.Object localObject1;  </li><li>
      if (((localObject1 = localEntry.key) == paramK) || (paramK.equals(localObject1))) {  </li><li>
        java.lang.Object localObject2 = localEntry.value;  </li><li>
        localEntry.value = paramV;  </li><li>
        localEntry.recordAccess(this);  </li><li>
        return localObject2;  </li><li>
      }  </li><li>
    }  </li><li>
  }  </li><li>
  this.modCount += 1;  </li><li>
  addEntry(i, paramK, paramV, j);  </li><li>
  return null;  </li><li>
}  </li><li>
  </li><li>
private V putForNullKey(V paramV)  </li><li>
{  </li><li>
  for (Entry localEntry = this.table[0]; localEntry != null; localEntry = localEntry.next)  </li><li>
    if (localEntry.key == null) {  </li><li>
      java.lang.Object localObject = localEntry.value;  </li><li>
      localEntry.value = paramV;  </li><li>
      localEntry.recordAccess(this);  </li><li>
      return localObject;  </li><li>
    }  </li><li>
  </li><li>
  this.modCount += 1;  </li><li>
  addEntry(0, null, paramV, 0);  </li><li>
  return null;  </li><li>
}  </li>

<p> </p>
<p>通过jconsole（或者thread dump），可以看到线程停在了transfer方法的while循环处。这个transfer方法的作用是，当Map中元素数超过阈值需要resize时，它负责把原Map中的元素映射到新Map中。我修改了HashMap，加上了@标记2和@标记3的代码片断，以打印出死循环时的状态，结果死循环线程总是出现类似这样的输出：“Thread-1,e&#x3D;&#x3D;next:false,e&#x3D;&#x3D;next.next:true,e:108928&#x3D;108928,next:108928&#x3D;108928,eq:true”。<br/><br>这个输出表明：<br/><br>1）这个Entry链中的两个Entry之间的关系是：e&#x3D;e.next.next，造成死循环。<br/><br>2）e.equals(e.next)，但e!&#x3D;e.next。因为测试例子中两个线程put的内容一样，并发时可能同一个key被保存了多个value，这种错误是在addEntry函数产生的，但这和线程死循环没有关系。</p>
<p>接下来就分析transfer中那个while循环了。先所说这个循环正常的功能：src[j]保存的是映射成同一个hash值的多个Entry的链表，这个src[j]可能为null，可能只有一个Entry，也可能由多个Entry链接起来。假设是多个Entry，原来的链是(src[j]&#x3D;a)-&gt;b（也就是src[j]&#x3D;a,a.next&#x3D;b,b.next&#x3D;null），经过while处理后得到了(newTable[i]&#x3D;b)-&gt;a。也就是说，把链表的next关系反向了。</p>
<p>再看看这个while中可能在多线程情况下引起问题的语句。针对两个线程t1和t2,这里它们可能的产生问题的执行序列做些个人分析：</p>
<p>1）假设同一个Entry列表[e-&gt;f-&gt;…]，t1先到，t2后到并都走到while中。t1执行“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”这使得e.next&#x3D;null（初始的newTable[i]为null），newTable[i]指向了e。这时t2执行了“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”，这使得e.next&#x3D;e，e死循环了。因为循环开始处的“final<br> Entry next &#x3D; e.next;”，尽管e自己死循环了，在最后的“e &#x3D; next;”后，两个线程都会跳过e继续执行下去。</p>
<p>2）在while中逐个遍历Entry链表中的Entry而把next关系反向时，newTable[i]成为了被交换的引用，可疑的语句在于“e.next &#x3D; newTable[i];”。假设链表e-&gt;f-&gt;g被t1处理成e&lt;-f&lt;-g，newTable[i]指向了g，这时t2进来了，它一执行“e.next &#x3D; newTable[i];”就使得e-&gt;g，造成了死循环。所以，理论上来说，死循环的Entry个数可能很多。尽管产生了死循环，但是t1执行到了死循环的右边，所以是会继续执行下去的，而t2如果执行“final<br> Entry next &#x3D; e.next;”的next为null，则也会继续执行下去，否则就进入了死循环。</p>
<p>3）似乎情况会更复杂，因为即便线程跳出了死循环，它下一次做resize进入transfer时，有可能因为之前的死循环Entry链表而被hang住（似乎是一定会被hang住）。也有可能，在put检查Entry链表时（@标记1），因为Entry链表的死循环而被hang住。也似乎有可能，活着的线程和死循环的线程同时执行在while里后，两个线程都能活着出去。所以，可能两个线程平安退出，可能一个线程hang在transfer中，可能两个线程都被hang住而又不一定在一个地方。</p>
<p>4）我反复的测试，出现一个线程被hang住的情况最多，都是e&#x3D;e.next.next造成的，这主要就是例子put两份增量数据造成的。我如果去掉@标记3的输出，有时也能复现两个线程都被hang住的情况，但加上后就很难复现出来。我又把put的数据改了下，比如让两个线程put范围不同的数据，就能复现出e&#x3D;e.next，两个线程都被hang住的情况。</p>
<p>上面罗哩罗嗦了很多，一开始我简单的分析后觉得似乎明白了怎么回事，可现在仔细琢磨后似乎又不明白了许多。有一个细节是，每次死循环的key的大小也是有据可循的，我就不打哈了。感觉，如果样本多些，可能出现问题的原因点会很多，也会更复杂，我姑且不再蛋疼下去。至于有人提到ConcurrentHashMap也有这个问题，我觉得不大可能，因为它的put操作是加锁的，如果有这个问题就不叫线程安全的Map了。</p>
<p><strong><strong>2、HashMap中Value可以相同，但是键不可以相同</strong></strong></p>
<p>当插入HashMap的key相同时，会覆盖原有的Value，且返回原Value值，看下面的程序：</p>
<li>
public class Test {  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
          </li><li>
        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();  </li><li>
  </li><li>
        //出入两个Value相同的值，没有问题  </li><li>
        map.put("egg", 1);  </li><li>
        map.put("niu", 1);  </li><li>
          </li><li>
        //插入key相同的值，看返回结果  </li><li>
        int egg = (Integer) map.put("egg", 3);  </li><li>
          </li><li>
        System.out.println(egg);   //输出1  </li><li>
        System.out.println(map.get("egg"));   //输出3，将原值1覆盖  </li><li>
        System.out.println(map.get("niu"));   //输出1  </li><li>
    }  </li><li>
}  </li>

<p>相同的键会被覆盖，且返回原值。</p>
<p><strong><strong>3、HashMap按值排序</strong></strong></p>
<p>给定一个数组，求出每个数据出现的次数并按照次数的由大到小排列出来。我们选用HashMap来做，key存储数组元素，值存储出现的次数，最后用Collections的sort方法对HashMap的值进行排序。代码如下：</p>
<li>
public class Test {  </li><li>
  </li><li>
    public static void main(String[] args) {  </li><li>
  </li><li>
        int data[] = { 2, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2,  </li><li>
                7, 8, 8, 7, 8, 7, 9, 0 };  </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();  </li><li>
        for (int i : data) {  </li><li>
            if (map.containsKey(i)) {//判断HashMap里是否存在  </li><li>
                map.put(i, map.get(i) + 1);//已存在，值+1  </li><li>
            } else {  </li><li>
                map.put(i, 1);//不存在，新增  </li><li>
            }  </li><li>
        }  </li><li>
        //map按值排序  </li><li>
        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(  </li><li>
                map.entrySet());  </li><li>
        Collections.sort(list, new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {  </li><li>
            public int compare(Map.Entry&lt;Integer, Integer&gt; o1,  </li><li>
                    Map.Entry&lt;Integer, Integer&gt; o2) {  </li><li>
                return (o2.getValue() - o1.getValue());  </li><li>
            }  </li><li>
        });  </li><li>
        for (Map.Entry&lt;Integer, Integer&gt; m : list) {  </li><li>
            System.out.println(m.getKey() + "-" + m.getValue());  </li><li>
        }  </li><li>
    }  </li><li>
  </li><li>
}  </li>

<p>输出：</p>
<p>2-6<br/><br>5-5<br/><br>3-4<br/><br>8-3<br/><br>7-3<br/><br>9-1<br/><br>0-1</p>
<li>
public HashMap()
 { </li><li>
        this.loadFactor
 = DEFAULT_LOAD_FACTOR; </li><li>
        threshold = (int)(DEFAULT_INITIAL_CAPACITY
 * DEFAULT_LOAD_FACTOR); </li><li>
        table = new Entry[DEFAULT_INITIAL_CAPACITY]; </li><li>
        init(); </li><li>
    } </li>

<p>loadFactor、threshold的值在此处没有起到作用，不过他们在后面的扩容方面会用到，此处只需理解table&#x3D;new Entry[DEFAULT_INITIAL_CAPACITY].说明，默认就是开辟16个大小的空间。另外一个重要的构造方法：</p>
<li>
public HashMap(int initialCapacity, float loadFactor)
 { </li><li>
        if (initialCapacity
 &lt; 0) </li><li>
            throw new IllegalArgumentException("Illegal
 initial capacity: " + </li><li>
                                               initialCapacity); </li><li>
        if (initialCapacity
 &gt; MAXIMUM_CAPACITY) </li><li>
            initialCapacity = MAXIMUM_CAPACITY; </li><li>
        if (loadFactor
 &lt;= 0 || Float.isNaN(loadFactor)) </li><li>
            throw new IllegalArgumentException("Illegal
 load factor: " + </li><li>
                                               loadFactor); </li><li>
 </li><li>
        // Find a power of 2 &gt;= initialCapacity </li><li>
        int capacity
 = 1; </li><li>
        while (capacity
 &lt; initialCapacity) </li><li>
            capacity &lt;&lt;= 1; </li><li>
 </li><li>
        this.loadFactor
 = loadFactor; </li><li>
        threshold = (int)(capacity
 * loadFactor); </li><li>
        table = new Entry[capacity]; </li><li>
        init(); </li><li>
    } </li>

<br/>
就是说传入参数的构造方法，我们把重点放在：

<li>
while (capacity
 &lt; initialCapacity) </li><li>
           capacity &lt;&lt;= 1; </li>

<br/>
上面，该代码的意思是，实际的开辟的空间要大于传入的第一个参数的值。举个例子： <br/>
new HashMap(7,0.8),loadFactor为0.8，capacity为7，通过上述代码后，capacity的值为：8.（1 &lt;&lt; 2的结果是4,2 &lt;&lt; 2的结果为8&lt;此处感谢网友wego1234的指正&gt;）。所以，最终capacity的值为8，最后通过new Entry[capacity]来创建大小为capacity的数组，所以，这种方法最红取决于capacity的大小。 <br/>
<em><strong>2、put(Object key,Object value)操作 <br/>
</strong></em>  <br/>
当调用put操作时，首先判断key是否为null，如下代码1处：

<li>
&lt;p&gt;public V
 put(K key, V value) { </li><li>
        if (key
 == null) </li><li>
            return putForNullKey(value); </li><li>
        int hash
 = hash(key.hashCode()); </li><li>
        int i
 = indexFor(hash, table.length); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[i]; e != null;
 e = e.next) { </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        }&lt;/p&gt;&lt;p&gt;        modCount++; </li><li>
        addEntry(hash, key, value, i); </li><li>
        return null; </li><li>
    }&lt;/p&gt; </li>

<br/>
如果**key是null**，则调用如下代码：

<li>
private V
 putForNullKey(V value) { </li><li>
        for (Entry&lt;K,V&gt;
 e = table[0]; e != null;
 e = e.next) { </li><li>
            if (e.key
 == null) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        } </li><li>
        modCount++; </li><li>
        addEntry(0, null,
 value, 0); </li><li>
        return null; </li><li>
    } </li>

<br/>
就是说，获取Entry的第一个元素table[0]，并基于第一个元素的next属性开始遍历，直到找到key为null的Entry，将其value设置为新的value值。 <br/>
如果没有找到key为null的元素，则调用如上述代码的addEntry(0, null, value, 0);增加一个新的entry，代码如下：

<li>
void addEntry(int hash,
 K key, V value, int bucketIndex)
 { </li><li>
    Entry&lt;K,V&gt; e = table[bucketIndex]; </li><li>
        table[bucketIndex] = new Entry&lt;K,V&gt;(hash,
 key, value, e); </li><li>
        if (size++
 &gt;= threshold) </li><li>
            resize(2 *
 table.length); </li><li>
    } </li>

<br/>
先获取第一个元素table[bucketIndex],传给e对象，新建一个entry，key为null，value为传入的value值，next为获取的e对象。如果容量大于threshold，容量扩大2倍。 <br/>
如果**key不为null**，这也是大多数的情况，重新看一下源码：

<li>
public V
 put(K key, V value) { </li><li>
        if (key
 == null) </li><li>
            return putForNullKey(value); </li><li>
        int hash
 = hash(key.hashCode());//---------------2--------------- </li><li>
        int i
 = indexFor(hash, table.length); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[i]; e != null;
 e = e.next) {//--------------3----------- </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { </li><li>
                V oldValue = e.value; </li><li>
                e.value = value; </li><li>
                e.recordAccess(this); </li><li>
                return oldValue; </li><li>
            } </li><li>
        }//-------------------4------------------ </li><li>
        modCount++;//----------------5---------- </li><li>
        addEntry(hash, key, value, i);-------------6----------- </li><li>
        return null; </li><li>
    } </li>

<br/>
看源码中2处，首先会进行key.hashCode()操作，获取key的哈希值，hashCode()是Object类的一个方法，为本地方法，内部实现比较复杂，我们 <br/>
会在后面作单独的关于Java中Native方法的分析中介绍。hash()的源码如下：

<li>
static int hash(int h)
 { </li><li>
        // This function ensures that
 hashCodes that differ only by </li><li>
        // constant multiples at each
 bit position have a bounded </li><li>
        // number of collisions (approximately
 8 at default load factor). </li><li>
        h ^= (h &gt;&gt;&gt; 20)
 ^ (h &gt;&gt;&gt; 12); </li><li>
        return h
 ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); </li><li>
    } </li>

<p>int i &#x3D; indexFor(hash, table.length);的意思，相当于int i &#x3D; hash % Entry[].length;得到i后，就是在Entry数组中的位置，（<del>上述代码5和6处是如果Entry数组中不存在新要增加的元素，则执行5,6处的代码，如果存在，即Hash冲突，则执行 3-4处的代码，此处HashMap中采用链地址法解决Hash冲突</del>。此处经网友<strong>bbycszh</strong>指正，发现上述陈述有些问题）。重新解释：其实不管Entry数组中i位置有无元素，都会去执行5-6处的代码，如果没有，则直接新增，如果有，则将新元素设置为Entry[0]，其next指针指向原有对象，即原有对象为Entry[1]。具体方法可以解释为下面的这段文字：（<strong>3-4处的代码只是检查在索引为i的这条链上有没有key重复的，有则替换且返回原值，程序不再去执行5-6处的代码，无则无处理</strong>）</p>
<p>上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。如， 第一个键值对A进来，通过计算其key的hash得到的i&#x3D;0，记做:Entry[0] &#x3D; A。一会后又进来一个键值对B，通过计算其i也等于0，现在怎么办？HashMap会这样做:B.next &#x3D; A,Entry[0] &#x3D; B,如果又进来C,i也等于0,那么C.next &#x3D; B,Entry[0] &#x3D; C；这样我们发现i&#x3D;0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,也就是说数组中存储的是最后插入的元素。</p>
<p>到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个i的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。 <br/></p>
<p><strong><strong>2、get(Object key)操作</strong></strong> <br/><br>get(Object key)操作时根据键来获取值，如果了解了put操作，get操作容易理解，先来看看源码的实现：</p>
<li>
public V
 get(Object key) { </li><li>
        if (key
 == null) </li><li>
            return getForNullKey(); </li><li>
        int hash
 = hash(key.hashCode()); </li><li>
        for (Entry&lt;K,V&gt;
 e = table[indexFor(hash, table.length)]; </li><li>
             e != null; </li><li>
             e = e.next) { </li><li>
            Object k; </li><li>
            if (e.hash
 == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))//-------------------1---------------- </li><li>
                return e.value; </li><li>
        } </li><li>
        return null; </li><li>
    } </li>

<br/>
意思就是：1、当key为null时，调用getForNullKey()，源码如下：

<li>
private V
 getForNullKey() { </li><li>
        for (Entry&lt;K,V&gt;
 e = table[0]; e != null;
 e = e.next) { </li><li>
            if (e.key
 == null) </li><li>
                return e.value; </li><li>
        } </li><li>
        return null; </li><li>
    } </li>

<p>2、当key不为null时，先根据hash函数得到hash值，在更具indexFor()得到i的值，循环遍历链表，如果有：key值等于已存在的key值，则返回其value。如上述get()代码1处判断。</p>
<p>总结下HashMap新增put和获取get操作：</p>
<li>
//存储时: </li><li>
int hash
 = key.hashCode(); </li><li>
int i
 = hash % Entry[].length; </li><li>
Entry[i] = value; </li><li>
 </li><li>
//取值时: </li><li>
int hash
 = key.hashCode(); </li><li>
int i
 = hash % Entry[].length; </li><li>
return Entry[i]; </li>

<p>理解了就比较简单。</p>
<p>此处附一个简单的HashMap小算法应用：</p>
<li>
package com.xtfggef.hashmap; </li><li>
 </li><li>
import java.util.HashMap; </li><li>
import java.util.Map; </li><li>
import java.util.Set; </li><li>
 </li><li>
/** </li><li>
* 打印在数组中出现n/2以上的元素 </li><li>
* 利用一个HashMap来存放数组元素及出现的次数 </li><li>
* @author erqing </li><li>
* </li><li>
*/ </li><li>
public class HashMapTest
 { </li><li>
     </li><li>
    public static void main(String[]
 args) { </li><li>
         </li><li>
        int []
 a = {2,3,2,2,1,4,2,2,2,7,9,6,2,2,3,1,0}; </li><li>
         </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); </li><li>
        for(int i=0;
 i&lt;a.length; i++){ </li><li>
            if(map.containsKey(a[i])){ </li><li>
                int tmp
 = map.get(a[i]); </li><li>
                tmp+=1; </li><li>
                map.put(a[i], tmp); </li><li>
            }else{ </li><li>
                map.put(a[i], 1); </li><li>
            } </li><li>
        } </li><li>
        Set&lt;Integer&gt; set = map.keySet();//------------1------------ </li><li>
        for (Integer
 s : set) { </li><li>
            if(map.get(s)&gt;=a.length/2){ </li><li>
                System.out.println(s); </li><li>
            } </li><li>
        }//--------------2--------------- </li><li>
    } </li><li>
} </li>

<p>此处注意两个地方，map.containsKey()，还有就是上述1-2处的代码。</p>
<p>理解了HashMap的上面的操作，其它的大多数方法都很容易理解了。搞清楚它的内部存储机制，一切OK！ <br/></p>
<p><strong>二、HashTable的内部存储结构</strong></p>
<p>HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：</p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。</p>
<p>2、HashTable不允许有null值的存在。</p>
<p>在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。</p>
<p><strong>三、HashTable和ConcurrentHashMap的比较</strong></p>
<p>如我开篇所说一样，ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？</p>
<p>之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，<strong>锁住的都是对象整体</strong>，但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。关于concurrentLevel稍后介绍。</p>
<p><strong><strong>1、构造方法</strong></strong></p>
<p>为了容易理解，我们先从构造函数说起。ConcurrentHashMap是基于一个叫Segment数组的，其实和Entry类似，如下：</p>
<li>
public ConcurrentHashMap() </li><li>
  { </li><li>
    this(16, 0.75F, 16); </li><li>
  } </li>

<br/>
默认传入值16，调用下面的方法：

<li>
public ConcurrentHashMap(int paramInt1, float paramFloat, int paramInt2) </li><li>
  { </li><li>
    if ((paramFloat
 &lt;= 0F) || (paramInt1 &lt; 0)
 || (paramInt2 &lt;= 0)) </li><li>
      throw new IllegalArgumentException(); </li><li>
 </li><li>
    if (paramInt2
 &gt; 65536) { </li><li>
      paramInt2 = 65536; </li><li>
    } </li><li>
 </li><li>
    int i
 = 0; </li><li>
    int j
 = 1; </li><li>
    while (j
 &lt; paramInt2) { </li><li>
      ++i; </li><li>
      j &lt;&lt;= 1; </li><li>
    } </li><li>
    this.segmentShift
 = (32 - i); </li><li>
    this.segmentMask
 = (j - 1); </li><li>
    this.segments
 = Segment.newArray(j); </li><li>
 </li><li>
    if (paramInt1
 &gt; 1073741824) </li><li>
      paramInt1 = 1073741824; </li><li>
    int k
 = paramInt1 / j; </li><li>
    if (k
 * j &lt; paramInt1) </li><li>
      ++k; </li><li>
    int l
 = 1; </li><li>
    while (l
 &lt; k) </li><li>
      l &lt;&lt;= 1; </li><li>
 </li><li>
    for (int i1
 = 0; i1 &lt; this.segments.length;
 ++i1) </li><li>
      this.segments[i1]
 = new Segment(l, paramFloat); </li><li>
  } </li>

<br/>
你会发现比HashMap的构造函数多一个参数，paramInt1就是我们之前谈过的initialCapacity，就是数组的初始化大小，paramfloat为loadFactor（装载因子），而paramInt2则是我们所要说的concurrentLevel，这三个值分别被初始化为16,0.75,16，经过：

<li>
while (j
 &lt; paramInt2) { </li><li>
      ++i; </li><li>
      j &lt;&lt;= 1; </li><li>
    } </li>

<br/>
后，j就是我们最终要开辟的数组的size值，当paramInt1为16时，计算出来的size值就是16.通过：


<p>this.segments &#x3D; Segment.newArray(j)后，我们看出了，最终稿创建的Segment数组的大小为16.最终创建Segment对象时：</p>
<li>
this.segments[i1]
 = new Segment(cap,
 paramFloat); </li>

<p>需要cap值，而cap值来源于：</p>
<li>
int k
 = paramInt1 / j; </li><li>
  if (k
 * j &lt; paramInt1) </li><li>
    ++k; </li><li>
  int cap
 = 1; </li><li>
  while (cap
 &lt; k) </li><li>
    cap &lt;&lt;= 1; </li>

<p>组后创建大小为cap的数组。最后根据数组的大小及paramFloat的值算出了threshold的值：</p>
<p>this.threshold &#x3D; (int)(paramArrayOfHashEntry.length * this.loadFactor)。</p>
<p><strong><strong>2、put操作</strong></strong></p>
<li>
public V
 put(K paramK, V paramV) </li><li>
  { </li><li>
    if (paramV
 == null) </li><li>
      throw new NullPointerException(); </li><li>
    int i
 = hash(paramK.hashCode()); </li><li>
    return segmentFor(i).put(paramK,
 i, paramV, false); </li><li>
  } </li>

<br/>
与HashMap不同的是，如果key为null，直接抛出NullPointer异常，之后，同样先计算hashCode的值，再计算hash值，不过此处hash函数和HashMap中的不一样：

<li>
private static int hash(int paramInt) </li><li>
  { </li><li>
    paramInt += (paramInt &lt;&lt; 15 ^ 0xFFFFCD7D); </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 10; </li><li>
    paramInt += (paramInt &lt;&lt; 3); </li><li>
    paramInt ^= paramInt &gt;&gt;&gt; 6; </li><li>
    paramInt += (paramInt &lt;&lt; 2)
 + (paramInt &lt;&lt; 14); </li><li>
    return (paramInt
 ^ paramInt &gt;&gt;&gt; 16); </li><li>
  } </li>

<br/>
 

<li>
final Segment&lt;K,
 V&gt; segmentFor(int paramInt) </li><li>
  { </li><li>
    return this.segments[(paramInt
 &gt;&gt;&gt; this.segmentShift
 &amp; this.segmentMask)]; </li><li>
  } </li>

<br/>
根据上述代码找到Segment对象后，调用put来操作：

<li>
V put(K paramK, int paramInt,
 V paramV, boolean paramBoolean) </li><li>
{ </li><li>
  lock(); </li><li>
  try { </li><li>
    Object localObject1; </li><li>
    Object localObject2; </li><li>
    int i
 = this.count; </li><li>
    if (i++
 &gt; this.threshold) </li><li>
      rehash(); </li><li>
    ConcurrentHashMap.HashEntry[] arrayOfHashEntry = this.table; </li><li>
    int j
 = paramInt &amp; arrayOfHashEntry.length - 1; </li><li>
    ConcurrentHashMap.HashEntry localHashEntry1 = arrayOfHashEntry[j]; </li><li>
    ConcurrentHashMap.HashEntry localHashEntry2 = localHashEntry1; </li><li>
    while ((localHashEntry2
 != null) &amp;&amp; (((localHashEntry2.hash
 != paramInt) || (!(paramK.equals(localHashEntry2.key)))))) { </li><li>
      localHashEntry2 = localHashEntry2.next; </li><li>
    } </li><li>
 </li><li>
    if (localHashEntry2
 != null) { </li><li>
      localObject1 = localHashEntry2.value; </li><li>
      if (!(paramBoolean)) </li><li>
        localHashEntry2.value = paramV; </li><li>
    } </li><li>
    else { </li><li>
      localObject1 = null; </li><li>
      this.modCount
 += 1; </li><li>
      arrayOfHashEntry[j] = new ConcurrentHashMap.HashEntry(paramK,
 paramInt, localHashEntry1, paramV); </li><li>
      this.count
 = i; </li><li>
    } </li><li>
    return localObject1; </li><li>
  } finally { </li><li>
    unlock(); </li><li>
  } </li><li>
} </li>

<br/>
先调用lock()，lock是ReentrantLock类的一个方法，用当前存储的个数+1来和threshold比较，如果大于threshold，则进行rehash，将当前的容量扩大2倍，重新进行hash。之后对hash的值和数组大小-1进行按位于操作后，得到当前的key需要放入的位置，从这儿开始，和HashMap一样。


<p>从上述的分析看出，<strong><strong>ConcurrentHashMap基于concurrentLevel划分出了多个Segment来对key-value进行存储，从而避免每次锁定整个数组，在默认的情况下，允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</strong></strong></p>
<p>在多线程的环境中，相对于HashTable，ConcurrentHashMap会带来很大的性能提升！</p>
<p><strong>四、HashMap常见问题分析</strong></p>
<p><strong><strong>1、此处我觉得</strong></strong>网友**<a href="mailto:huxb23@126">huxb23@126</a>**的一篇文章说的很好，<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/"><strong>分析多线程并发写HashMap线程被hang住的原因</strong></a> ，因为是优秀的资源，此处我整理下搬到这儿。</p>
<p>以下内容转自博文：<a target="_blank" rel="noopener" href="http://blog.163.com/huxb23@126/blog/static/625898182011211318854/">http:&#x2F;&#x2F;blog.163.com&#x2F;huxb23@126&#x2F;blog&#x2F;static&#x2F;625898182011211318854&#x2F;</a> </p>
<p>先看原问题代码：</p>
<li>
import java.util.HashMap; </li><li>
 </li><li>
public class TestLock
 { </li><li>
 </li><li>
    private HashMap
 map = new HashMap(); </li><li>
 </li><li>
    public TestLock()
 { </li><li>
        Thread t1 = new Thread()
 { </li><li>
            public void run()
 { </li><li>
                for (int i
 = 0; i &lt; 50000;
 i++) { </li><li>
                    map.put(new Integer(i),
 i); </li><li>
                } </li><li>
                System.out.println("t1 over"); </li><li>
            } </li><li>
        }; </li><li>
 </li><li>
        Thread t2 = new Thread()
 { </li><li>
            public void run()
 { </li><li>
                for (int i
 = 0; i &lt; 50000;
 i++) { </li><li>
                    map.put(new Integer(i),
 i); </li><li>
                } </li><li>
 </li><li>
                System.out.println("t2 over"); </li><li>
            } </li><li>
        }; </li><li>
 </li><li>
        t1.start(); </li><li>
        t2.start(); </li><li>
 </li><li>
    } </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
        new TestLock(); </li><li>
    } </li><li>
} </li>

<br/>
就是启了两个线程，不断的往一个非线程安全的HashMap中put内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会两个线程都被hang住。说到这里，你如果觉得不好好学习ConcurrentHashMap而在这瞎折腾就手下留情跳过吧。 <br/>
好吧，分析下HashMap的put函数源码看看问题出在哪，这里就罗列出相关代码（jdk1.6）：

<li>
public V
 put(K paramK, V paramV) </li><li>
{ </li><li>
  if (paramK
 == null) </li><li>
    return putForNullKey(paramV); </li><li>
  int i
 = hash(paramK.hashCode()); </li><li>
  int j
 = indexFor(i, this.table.length); </li><li>
  for (Entry
 localEntry = this.table[j];
 localEntry != null;
 localEntry = localEntry.next) </li><li>
  { </li><li>
    if (localEntry.hash
 == i) { java.lang.Object localObject1; </li><li>
      if (((localObject1
 = localEntry.key) == paramK) || (paramK.equals(localObject1))) { </li><li>
        java.lang.Object localObject2 = localEntry.value; </li><li>
        localEntry.value = paramV; </li><li>
        localEntry.recordAccess(this); </li><li>
        return localObject2; </li><li>
      } </li><li>
    } </li><li>
  } </li><li>
  this.modCount
 += 1; </li><li>
  addEntry(i, paramK, paramV, j); </li><li>
  return null; </li><li>
} </li><li>
 </li><li>
private V
 putForNullKey(V paramV) </li><li>
{ </li><li>
  for (Entry
 localEntry = this.table[0];
 localEntry != null;
 localEntry = localEntry.next) </li><li>
    if (localEntry.key
 == null) { </li><li>
      java.lang.Object localObject = localEntry.value; </li><li>
      localEntry.value = paramV; </li><li>
      localEntry.recordAccess(this); </li><li>
      return localObject; </li><li>
    } </li><li>
 </li><li>
  this.modCount
 += 1; </li><li>
  addEntry(0, null,
 paramV, 0); </li><li>
  return null; </li><li>
} </li>

<p> </p>
<p>通过jconsole（或者thread dump），可以看到线程停在了transfer方法的while循环处。这个transfer方法的作用是，当Map中元素数超过阈值需要resize时，它负责把原Map中的元素映射到新Map中。我修改了HashMap，加上了@标记2和@标记3的代码片断，以打印出死循环时的状态，结果死循环线程总是出现类似这样的输出：“Thread-1,e&#x3D;&#x3D;next:false,e&#x3D;&#x3D;next.next:true,e:108928&#x3D;108928,next:108928&#x3D;108928,eq:true”。 <br/><br>这个输出表明： <br/><br>1）这个Entry链中的两个Entry之间的关系是：e&#x3D;e.next.next，造成死循环。 <br/><br>2）e.equals(e.next)，但e!&#x3D;e.next。因为测试例子中两个线程put的内容一样，并发时可能同一个key被保存了多个value，这种错误是在addEntry函数产生的，但这和线程死循环没有关系。</p>
<p>接下来就分析transfer中那个while循环了。先所说这个循环正常的功能：src[j]保存的是映射成同一个hash值的多个Entry的链表，这个src[j]可能为null，可能只有一个Entry，也可能由多个Entry链接起来。假设是多个Entry，原来的链是(src[j]&#x3D;a)-&gt;b（也就是src[j]&#x3D;a,a.next&#x3D;b,b.next&#x3D;null），经过while处理后得到了(newTable[i]&#x3D;b)-&gt;a。也就是说，把链表的next关系反向了。</p>
<p>再看看这个while中可能在多线程情况下引起问题的语句。针对两个线程t1和t2,这里它们可能的产生问题的执行序列做些个人分析：</p>
<p>1）假设同一个Entry列表[e-&gt;f-&gt;…]，t1先到，t2后到并都走到while中。t1执行“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”这使得e.next&#x3D;null（初始的newTable[i]为null），newTable[i]指向了e。这时t2执行了“e.next &#x3D; newTable[i];newTable[i] &#x3D; e;”，这使得e.next&#x3D;e，e死循环了。因为循环开始处的“final<br> Entry next &#x3D; e.next;”，尽管e自己死循环了，在最后的“e &#x3D; next;”后，两个线程都会跳过e继续执行下去。</p>
<p>2）在while中逐个遍历Entry链表中的Entry而把next关系反向时，newTable[i]成为了被交换的引用，可疑的语句在于“e.next &#x3D; newTable[i];”。假设链表e-&gt;f-&gt;g被t1处理成e&lt;-f&lt;-g，newTable[i]指向了g，这时t2进来了，它一执行“e.next &#x3D; newTable[i];”就使得e-&gt;g，造成了死循环。所以，理论上来说，死循环的Entry个数可能很多。尽管产生了死循环，但是t1执行到了死循环的右边，所以是会继续执行下去的，而t2如果执行“final<br> Entry next &#x3D; e.next;”的next为null，则也会继续执行下去，否则就进入了死循环。</p>
<p>3）似乎情况会更复杂，因为即便线程跳出了死循环，它下一次做resize进入transfer时，有可能因为之前的死循环Entry链表而被hang住（似乎是一定会被hang住）。也有可能，在put检查Entry链表时（@标记1），因为Entry链表的死循环而被hang住。也似乎有可能，活着的线程和死循环的线程同时执行在while里后，两个线程都能活着出去。所以，可能两个线程平安退出，可能一个线程hang在transfer中，可能两个线程都被hang住而又不一定在一个地方。</p>
<p>4）我反复的测试，出现一个线程被hang住的情况最多，都是e&#x3D;e.next.next造成的，这主要就是例子put两份增量数据造成的。我如果去掉@标记3的输出，有时也能复现两个线程都被hang住的情况，但加上后就很难复现出来。我又把put的数据改了下，比如让两个线程put范围不同的数据，就能复现出e&#x3D;e.next，两个线程都被hang住的情况。</p>
<p>上面罗哩罗嗦了很多，一开始我简单的分析后觉得似乎明白了怎么回事，可现在仔细琢磨后似乎又不明白了许多。有一个细节是，每次死循环的key的大小也是有据可循的，我就不打哈了。感觉，如果样本多些，可能出现问题的原因点会很多，也会更复杂，我姑且不再蛋疼下去。至于有人提到ConcurrentHashMap也有这个问题，我觉得不大可能，因为它的put操作是加锁的，如果有这个问题就不叫线程安全的Map了。</p>
<p><strong><strong>2、HashMap中Value可以相同，但是键不可以相同</strong></strong></p>
<p>当插入HashMap的key相同时，会覆盖原有的Value，且返回原Value值，看下面的程序：</p>
<li>
public class Test
 { </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
         </li><li>
        HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); </li><li>
 </li><li>
        //出入两个Value相同的值，没有问题 </li><li>
        map.put("egg", 1); </li><li>
        map.put("niu", 1); </li><li>
         </li><li>
        //插入key相同的值，看返回结果 </li><li>
        int egg
 = (Integer) map.put("egg", 3); </li><li>
         </li><li>
        System.out.println(egg);   //输出1 </li><li>
        System.out.println(map.get("egg"));   //输出3，将原值1覆盖 </li><li>
        System.out.println(map.get("niu"));   //输出1 </li><li>
    } </li><li>
} </li>

<p>相同的键会被覆盖，且返回原值。</p>
<p><strong><strong>3、HashMap按值排序</strong></strong></p>
<p>给定一个数组，求出每个数据出现的次数并按照次数的由大到小排列出来。我们选用HashMap来做，key存储数组元素，值存储出现的次数，最后用Collections的sort方法对HashMap的值进行排序。代码如下：</p>
<li>
public class Test
 { </li><li>
 </li><li>
    public static void main(String[]
 args) { </li><li>
 </li><li>
        int data[]
 = { 2, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, 3, 5, 2, </li><li>
                7, 8, 8, 7, 8, 7, 9, 0 }; </li><li>
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,
 Integer&gt;(); </li><li>
        for (int i
 : data) { </li><li>
            if (map.containsKey(i))
 {//判断HashMap里是否存在 </li><li>
                map.put(i, map.get(i) + 1);//已存在，值+1 </li><li>
            } else { </li><li>
                map.put(i, 1);//不存在，新增 </li><li>
            } </li><li>
        } </li><li>
        //map按值排序 </li><li>
        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer,
 Integer&gt;&gt;( </li><li>
                map.entrySet()); </li><li>
        Collections.sort(list, new Comparator&lt;Map.Entry&lt;Integer,
 Integer&gt;&gt;() { </li><li>
            public int compare(Map.Entry&lt;Integer,
 Integer&gt; o1, </li><li>
                    Map.Entry&lt;Integer, Integer&gt; o2) { </li><li>
                return (o2.getValue()
 - o1.getValue()); </li><li>
            } </li><li>
        }); </li><li>
        for (Map.Entry&lt;Integer,
 Integer&gt; m : list) { </li><li>
            System.out.println(m.getKey() + "-" +
 m.getValue()); </li><li>
        } </li><li>
    } </li><li>
 </li><li>
} </li>

<p>输出：</p>
<p>2-6 <br/><br>5-5 <br/><br>3-4 <br/><br>8-3 <br/><br>7-3 <br/><br>9-1 <br/><br>0-1</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/31/%E8%BD%AC%E8%BD%BD-%5B%E8%BD%AC%E8%BD%BD%5D%E5%B0%8F%E7%99%BD%E4%B8%80%E8%B7%AF%E8%B5%B0%E6%9D%A5%EF%BC%8C%E8%BF%9E%E7%BB%AD%E5%88%B7%E9%A2%98%E4%B8%89%E5%B9%B4%EF%BC%8C%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
